
/* 
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.11-0

  Combined SIL module
  module cli-mxp
  revision 2018-06-24
  namespace http://fulgor.com/ns/cli-mxp

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_not.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"
#include "cli-mxp.h"

/* module static variables */
static ncx_module_t *cli_mxp_mod;
static obj_template_t *mux_config_obj;
static obj_template_t *mux_state_obj;
static obj_template_t *mux_optical_line_status_obj;
static obj_template_t *mux_notify_activate_obj;
static obj_template_t *mux_notify_deactivate_obj;
static obj_template_t *mux_apply_config_obj;
static obj_template_t *mux_settings_obj;
static obj_template_t *mux_notify_obj;
static val_value_t *mux_config_val;

/* put your static variables here */

/********************************************************************
* FUNCTION y_cli_mxp_init_static_vars
* 
* initialize module static variables
* 
********************************************************************/
static void y_cli_mxp_init_static_vars (void)
{
  cli_mxp_mod = NULL;
  mux_config_obj = NULL;
  mux_state_obj = NULL;
  mux_optical_line_status_obj = NULL;
  mux_notify_activate_obj = NULL;
  mux_notify_deactivate_obj = NULL;
  mux_apply_config_obj = NULL;
  mux_settings_obj = NULL;
  mux_notify_obj = NULL;
  mux_config_val = NULL;

  /* init your static variables here */

} /* y_cli_mxp_init_static_vars */


/********************************************************************
* FUNCTION cli_mxp_mux_config_configuracion_edit
* 
* Edit database object callback
* Path: /mux-config/configuracion
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_configuracion_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_configuracion_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_configuracion_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_tipo_trafico_edit
* 
* Edit database object callback
* Path: /mux-config/tipo_trafico
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_tipo_trafico_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_tipo_trafico_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_tipo_trafico_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_tipo_fec_linea_edit
* 
* Edit database object callback
* Path: /mux-config/tipo_fec_linea
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_tipo_fec_linea_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_tipo_fec_linea_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_tipo_fec_linea_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_tipo_fec_cliente_edit
* 
* Edit database object callback
* Path: /mux-config/tipo_fec_cliente
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_tipo_fec_cliente_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_tipo_fec_cliente_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_tipo_fec_cliente_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_canal_edit
* 
* Edit database object callback
* Path: /mux-config/canal
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_canal_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_canal_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_canal_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_potencia_edit
* 
* Edit database object callback
* Path: /mux-config/potencia
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_potencia_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_potencia_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_potencia_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_cd_compensacion_edit
* 
* Edit database object callback
* Path: /mux-config/cd_compensacion
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_cd_compensacion_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_cd_compensacion_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_cd_compensacion_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_edfa_output_power_config_edit
* 
* Edit database object callback
* Path: /mux-config/edfa_output_power_config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_edfa_output_power_config_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_edfa_output_power_config_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_edfa_output_power_config_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_time_notify_config_edit
* 
* Edit database object callback
* Path: /mux-config/time_notify_config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_time_notify_config_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_time_notify_config_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_time_notify_config_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_value_notify_config_edit
* 
* Edit database object callback
* Path: /mux-config/value_notify_config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_value_notify_config_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_value_notify_config_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_value_notify_config_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_value_rx_power_notify_config_edit
* 
* Edit database object callback
* Path: /mux-config/value_rx_power_notify_config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_value_rx_power_notify_config_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_value_rx_power_notify_config_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_value_rx_power_notify_config_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_deviceneighbors_edit
* 
* Edit database object callback
* Path: /mux-config/deviceneighbors
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_deviceneighbors_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_deviceneighbors_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_deviceneighbors_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_edit
* 
* Edit database object callback
* Path: /mux-config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res == NO_ERR) {
      res = agt_check_cache(&mux_config_val, newval, curval, editop);
    }
    
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_edit */

/********************************************************************
* FUNCTION cli_mxp_mux_state_fpga_temperature_state_get
* 
* Get database object callback
* Path: /mux-state/fpga_temperature_state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_fpga_temperature_state_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int64 fpga_temperature_state;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_fpga_temperature_state_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the fpga_temperature_state var here, change zero */
  fpga_temperature_state = (const xmlChar *)"0.0";
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    fpga_temperature_state);

  return res;

} /* cli_mxp_mux_state_fpga_temperature_state_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_board_humidity_state_get
* 
* Get database object callback
* Path: /mux-state/board_humidity_state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_board_humidity_state_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int16 board_humidity_state;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_board_humidity_state_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the board_humidity_state var here, change zero */
  board_humidity_state = 0;
  VAL_INT16(dstval) = board_humidity_state;

  return res;

} /* cli_mxp_mux_state_board_humidity_state_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_edfa_output_power_state_get
* 
* Get database object callback
* Path: /mux-state/edfa_output_power_state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_edfa_output_power_state_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int64 edfa_output_power_state;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_edfa_output_power_state_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the edfa_output_power_state var here, change zero */
  edfa_output_power_state = (const xmlChar *)"0.0";
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    edfa_output_power_state);

  return res;

} /* cli_mxp_mux_state_edfa_output_power_state_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_xfp_tx_power_get
* 
* Get database object callback
* Path: /mux-state/xfp_tx_power
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_xfp_tx_power_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int64 xfp_tx_power;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_xfp_tx_power_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the xfp_tx_power var here, change zero */
  xfp_tx_power = (const xmlChar *)"0.0";
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    xfp_tx_power);

  return res;

} /* cli_mxp_mux_state_xfp_tx_power_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_xfp_rx_power_get
* 
* Get database object callback
* Path: /mux-state/xfp_rx_power
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_xfp_rx_power_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int64 xfp_rx_power;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_xfp_rx_power_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the xfp_rx_power var here, change zero */
  xfp_rx_power = (const xmlChar *)"0.0";
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    xfp_rx_power);

  return res;

} /* cli_mxp_mux_state_xfp_rx_power_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_device_manufacturer_get
* 
* Get database object callback
* Path: /mux-state/device_manufacturer
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_device_manufacturer_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *device_manufacturer;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_device_manufacturer_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the device_manufacturer var here, change EMPTY_STRING */
  device_manufacturer = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    device_manufacturer);

  return res;

} /* cli_mxp_mux_state_device_manufacturer_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_device_swVersion_get
* 
* Get database object callback
* Path: /mux-state/device_swVersion
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_device_swVersion_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *device_swVersion;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_device_swVersion_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the device_swVersion var here, change EMPTY_STRING */
  device_swVersion = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    device_swVersion);

  return res;

} /* cli_mxp_mux_state_device_swVersion_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_device_hwVersion_get
* 
* Get database object callback
* Path: /mux-state/device_hwVersion
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_device_hwVersion_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *device_hwVersion;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_device_hwVersion_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the device_hwVersion var here, change EMPTY_STRING */
  device_hwVersion = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    device_hwVersion);

  return res;

} /* cli_mxp_mux_state_device_hwVersion_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_device_boardId_get
* 
* Get database object callback
* Path: /mux-state/device_boardId
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_device_boardId_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *device_boardId;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_device_boardId_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the device_boardId var here, change EMPTY_STRING */
  device_boardId = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    device_boardId);

  return res;

} /* cli_mxp_mux_state_device_boardId_get */


/********************************************************************
* FUNCTION cli_mxp_mux_state_mro
* 
* Make read-only top-level node
* Path: /mux-state
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
  cli_mxp_mux_state_mro (void)
{
  val_value_t *parentval = NULL, *childval = NULL;
  status_t res = NO_ERR;


  /* add /mux-state */
  res = agt_add_top_container(mux_state_obj, &parentval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /mux-state/fpga_temperature_state */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_fpga_temperature_state,
    cli_mxp_mux_state_fpga_temperature_state_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/board_humidity_state */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_board_humidity_state,
    cli_mxp_mux_state_board_humidity_state_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/edfa_output_power_state */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_edfa_output_power_state,
    cli_mxp_mux_state_edfa_output_power_state_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/xfp_tx_power */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_xfp_tx_power,
    cli_mxp_mux_state_xfp_tx_power_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/xfp_rx_power */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_xfp_rx_power,
    cli_mxp_mux_state_xfp_rx_power_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/device_manufacturer */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_device_manufacturer,
    cli_mxp_mux_state_device_manufacturer_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/device_swVersion */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_device_swVersion,
    cli_mxp_mux_state_device_swVersion_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/device_hwVersion */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_device_hwVersion,
    cli_mxp_mux_state_device_hwVersion_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/device_boardId */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_device_boardId,
    cli_mxp_mux_state_device_boardId_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* cli_mxp_mux_state_mro */

/********************************************************************
* FUNCTION cli_mxp_mux_optical_line_status_brctl_showstp_br0_get
* 
* Get database object callback
* Path: /mux-optical-line-status/brctl_showstp_br0
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_optical_line_status_brctl_showstp_br0_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *brctl_showstp_br0;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_optical_line_status_brctl_showstp_br0_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the brctl_showstp_br0 var here, change EMPTY_STRING */
  brctl_showstp_br0 = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    brctl_showstp_br0);

  return res;

} /* cli_mxp_mux_optical_line_status_brctl_showstp_br0_get */


/********************************************************************
* FUNCTION cli_mxp_mux_optical_line_status_mro
* 
* Make read-only top-level node
* Path: /mux-optical-line-status
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
  cli_mxp_mux_optical_line_status_mro (void)
{
  val_value_t *parentval = NULL, *childval = NULL;
  status_t res = NO_ERR;


  /* add /mux-optical-line-status */
  res = agt_add_top_container(mux_optical_line_status_obj, &parentval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /mux-optical-line-status/brctl_showstp_br0 */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_brctl_showstp_br0,
    cli_mxp_mux_optical_line_status_brctl_showstp_br0_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* cli_mxp_mux_optical_line_status_mro */


/********************************************************************
* FUNCTION y_cli_mxp_mux_notify_activate_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_notify_activate_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;


  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_cli_mxp_mux_notify_activate_validate */


/********************************************************************
* FUNCTION y_cli_mxp_mux_notify_activate_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_notify_activate_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_cli_mxp_mux_notify_activate_invoke */


/********************************************************************
* FUNCTION y_cli_mxp_mux_notify_deactivate_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_notify_deactivate_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;


  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_cli_mxp_mux_notify_deactivate_validate */


/********************************************************************
* FUNCTION y_cli_mxp_mux_notify_deactivate_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_notify_deactivate_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_cli_mxp_mux_notify_deactivate_invoke */


/********************************************************************
* FUNCTION y_cli_mxp_mux_apply_config_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_apply_config_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;


  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_cli_mxp_mux_apply_config_validate */


/********************************************************************
* FUNCTION y_cli_mxp_mux_apply_config_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_apply_config_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_cli_mxp_mux_apply_config_invoke */


/********************************************************************
* FUNCTION y_cli_mxp_mux_settings_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_settings_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;


  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_cli_mxp_mux_settings_validate */


/********************************************************************
* FUNCTION y_cli_mxp_mux_settings_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_settings_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_cli_mxp_mux_settings_invoke */


/********************************************************************
* FUNCTION y_cli_mxp_mux_notify_send
* 
* Send a y_cli_mxp_mux_notify notification
* Called by your code when notification event occurs
* 
********************************************************************/
void y_cli_mxp_mux_notify_send (
  const xmlChar *ringtone)
{
  agt_not_msg_t *notif;
  val_value_t *parmval;
  status_t res = NO_ERR;


  if (LOGDEBUG) {
    log_debug("\nGenerating <mux-notify> notification");
  }
  
  notif = agt_not_new_notification(mux_notify_obj);
  if (notif == NULL) {
    log_error("\nError: malloc failed, cannot send "
    "<mux-notify> notification");
    return;
  }
  
  /* add ringtone to payload */
  parmval = agt_make_leaf(
    mux_notify_obj,
    y_cli_mxp_N_ringtone,
    ringtone,
    &res);
  if (parmval == NULL) {
    log_error(
      "\nError: make leaf failed (%s), cannot send "
      "<mux-notify> notification",
      get_error_string(res));
  } else {
    agt_not_add_to_payload(notif, parmval);
  }
  
  agt_not_queue_notification(notif);
  
} /* y_cli_mxp_mux_notify_send */

/********************************************************************
* FUNCTION y_cli_mxp_init
* 
* initialize the cli-mxp server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_cli_mxp_init (
  const xmlChar *modname,
  const xmlChar *revision)
{
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  y_cli_mxp_init_static_vars();

  /* change if custom handling done */
  if (xml_strcmp(modname, y_cli_mxp_M_cli_mxp)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }

  if (revision && xml_strcmp(revision, y_cli_mxp_R_cli_mxp)) {
    return ERR_NCX_WRONG_VERSION;
  }
  res = ncxmod_load_module(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_R_cli_mxp,
    &agt_profile->agt_savedevQ,
    &cli_mxp_mod);
  if (res != NO_ERR) {
    return res;
  }

  mux_config_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_config);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_state_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_state);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_optical_line_status_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_optical_line_status);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_notify_activate_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_notify_activate);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_notify_deactivate_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_notify_deactivate);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_apply_config_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_apply_config);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_settings_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_settings);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_notify_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_notify);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_notify_activate,
    AGT_RPC_PH_VALIDATE,
    y_cli_mxp_mux_notify_activate_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_notify_activate,
    AGT_RPC_PH_INVOKE,
    y_cli_mxp_mux_notify_activate_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_notify_deactivate,
    AGT_RPC_PH_VALIDATE,
    y_cli_mxp_mux_notify_deactivate_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_notify_deactivate,
    AGT_RPC_PH_INVOKE,
    y_cli_mxp_mux_notify_deactivate_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_apply_config,
    AGT_RPC_PH_VALIDATE,
    y_cli_mxp_mux_apply_config_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_apply_config,
    AGT_RPC_PH_INVOKE,
    y_cli_mxp_mux_apply_config_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_settings,
    AGT_RPC_PH_VALIDATE,
    y_cli_mxp_mux_settings_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_settings,
    AGT_RPC_PH_INVOKE,
    y_cli_mxp_mux_settings_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/configuracion",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_configuracion_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/tipo_trafico",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_tipo_trafico_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/tipo_fec_linea",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_tipo_fec_linea_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/tipo_fec_cliente",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_tipo_fec_cliente_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/canal",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_canal_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/potencia",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_potencia_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/cd_compensacion",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_cd_compensacion_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/edfa_output_power_config",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_edfa_output_power_config_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/time_notify_config",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_time_notify_config_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/value_notify_config",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_value_notify_config_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/value_rx_power_notify_config",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_value_rx_power_notify_config_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/deviceneighbors",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_deviceneighbors_edit);
  if (res != NO_ERR) {
    return res;
  }

  /* put your module initialization code here */
  
  return res;
} /* y_cli_mxp_init */

/********************************************************************
* FUNCTION y_cli_mxp_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_cli_mxp_init2 (void)
{
  status_t res = NO_ERR;

  mux_config_val = agt_init_cache(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_config,
    &res);
  if (res != NO_ERR) {
    return res;
  }

  res = cli_mxp_mux_optical_line_status_mro();
  if (res != NO_ERR) {
    return res;
  }

  res = cli_mxp_mux_state_mro();
  if (res != NO_ERR) {
    return res;
  }

  /* put your init2 code here */

  return res;
} /* y_cli_mxp_init2 */

/********************************************************************
* FUNCTION y_cli_mxp_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void y_cli_mxp_cleanup (void)
{
  
  agt_rpc_unregister_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_notify_activate);
  
  agt_rpc_unregister_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_notify_deactivate);
  
  agt_rpc_unregister_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_apply_config);
  
  agt_rpc_unregister_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_settings);
  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/configuracion");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/tipo_trafico");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/tipo_fec_linea");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/tipo_fec_cliente");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/canal");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/potencia");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/cd_compensacion");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/edfa_output_power_config");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/time_notify_config");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/value_notify_config");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/value_rx_power_notify_config");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/deviceneighbors");

  /* put your cleanup code here */
  
} /* y_cli_mxp_cleanup */

/* END cli_mxp.c */
