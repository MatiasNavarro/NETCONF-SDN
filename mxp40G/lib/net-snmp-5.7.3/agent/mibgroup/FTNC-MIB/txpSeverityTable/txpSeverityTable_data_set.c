/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "../../txpSeverityTable.h"

#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <stdlib.h>
#include "../../../../lib/hl_configs/definitions.h"

void shm_handler_create(Monitor *pt_monitor_struct);
Monitor *pt_monitor_struct;

/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table txpSeverityTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * FTNC-MIB::txpSeverityTable is subid 1 of txpAlarms.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1, length: 12
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * txpSeverityTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * txpSeverityTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int txpSeverityTable_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
	 DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTable_undo_setup","called\n"));

    int rc = MFD_SUCCESS;

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup txpSeverityTable undo.
     * set up txpSeverityTable undo information, in preparation for a set.
     * Undo storage is in (* txpSeverityN5p2vDigital_val_ptr )*
     */

    return rc;
} /* txpSeverityTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int txpSeverityTable_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
	DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTable_undo","called\n"));

    int rc = MFD_SUCCESS;

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> txpSeverityTable undo.
     * txpSeverityTable undo information, in response to a failed set.
     * Undo storage is in (* txpSeverityN5p2vDigital_val_ptr )*
     */

    return rc;
} /* txpSeverityTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int txpSeverityTable_undo_cleanup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
	DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTable_undo_cleanup","called\n"));

    int rc = MFD_SUCCESS;

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup txpSeverityTable undo.
     * Undo storage is in (* txpSeverityN5p2vDigital_val_ptr )*
     */

    return rc;
} /* txpSeverityTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * txpSeverityTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param txpSeverityTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int txpSeverityTable_commit( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
	DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTable_commit","called\n"));

    int rc = MFD_SUCCESS;
    int             save_flags;

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit txpSeverityTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_TXPSEVERITYEOL_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYEOL_FLAG; /* clear txpSeverityEol */
       /*
        * TODO:482:o: |-> commit column txpSeverityEol.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityEol commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityEol
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYEOL_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYMODTEMP_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYMODTEMP_FLAG; /* clear txpSeverityModTemp */
       /*
        * TODO:482:o: |-> commit column txpSeverityModTemp.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityModTemp commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityModTemp
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYMODTEMP_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYTXOOA_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYTXOOA_FLAG; /* clear txpSeverityTxooa */
       /*
        * TODO:482:o: |-> commit column txpSeverityTxooa.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityTxooa commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityTxooa
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYTXOOA_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYTXLOF_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYTXLOF_FLAG; /* clear txpSeverityTxLof */
       /*
        * TODO:482:o: |-> commit column txpSeverityTxLof.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityTxLof commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityTxLof
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYTXLOF_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYTXDSC_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYTXDSC_FLAG; /* clear txpSeverityTxDsc */
       /*
        * TODO:482:o: |-> commit column txpSeverityTxDsc.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityTxDsc commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityTxDsc
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYTXDSC_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYLSWAV_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYLSWAV_FLAG; /* clear txpSeverityLsWav */
       /*
        * TODO:482:o: |-> commit column txpSeverityLsWav.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityLsWav commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityLsWav
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYLSWAV_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYLSBIAS_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYLSBIAS_FLAG; /* clear txpSeverityLsBias */
       /*
        * TODO:482:o: |-> commit column txpSeverityLsBias.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityLsBias commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityLsBias
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYLSBIAS_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYLSTEMP_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYLSTEMP_FLAG; /* clear txpSeverityLsTemp */
       /*
        * TODO:482:o: |-> commit column txpSeverityLsTemp.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityLsTemp commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityLsTemp
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYLSTEMP_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYTXLOCK_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYTXLOCK_FLAG; /* clear txpSeverityTxLock */
       /*
        * TODO:482:o: |-> commit column txpSeverityTxLock.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityTxLock commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityTxLock
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYTXLOCK_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYLSPOW_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYLSPOW_FLAG; /* clear txpSeverityLsPow */
       /*
        * TODO:482:o: |-> commit column txpSeverityLsPow.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityLsPow commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityLsPow
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYLSPOW_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYMODBIAS_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYMODBIAS_FLAG; /* clear txpSeverityModBias */
       /*
        * TODO:482:o: |-> commit column txpSeverityModBias.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityModBias commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityModBias
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYMODBIAS_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYLATCHEDTXFIFO_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYLATCHEDTXFIFO_FLAG; /* clear txpSeverityLatchedTxFifo */
       /*
        * TODO:482:o: |-> commit column txpSeverityLatchedTxFifo.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityLatchedTxFifo commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityLatchedTxFifo
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYLATCHEDTXFIFO_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYRXPOW_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYRXPOW_FLAG; /* clear txpSeverityRxPow */
       /*
        * TODO:482:o: |-> commit column txpSeverityRxPow.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityRxPow commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityRxPow
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYRXPOW_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYRXLOS_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYRXLOS_FLAG; /* clear txpSeverityRxLos */
       /*
        * TODO:482:o: |-> commit column txpSeverityRxLos.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityRxLos commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityRxLos
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYRXLOS_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYRXLOCK_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYRXLOCK_FLAG; /* clear txpSeverityRxLock */
       /*
        * TODO:482:o: |-> commit column txpSeverityRxLock.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityRxLock commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityRxLock
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYRXLOCK_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYRXS_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYRXS_FLAG; /* clear txpSeverityRxs */
       /*
        * TODO:482:o: |-> commit column txpSeverityRxs.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityRxs commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityRxs
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYRXS_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYPRBSERR_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYPRBSERR_FLAG; /* clear txpSeverityPrbsErr */
       /*
        * TODO:482:o: |-> commit column txpSeverityPrbsErr.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityPrbsErr commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityPrbsErr
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYPRBSERR_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYPSUMMARY_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYPSUMMARY_FLAG; /* clear txpSeverityPsummary */
       /*
        * TODO:482:o: |-> commit column txpSeverityPsummary.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityPsummary commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityPsummary
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYPSUMMARY_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYP5VANALOG_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYP5VANALOG_FLAG; /* clear txpSeverityP5vAnalog */
       /*
        * TODO:482:o: |-> commit column txpSeverityP5vAnalog.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityP5vAnalog commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityP5vAnalog
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYP5VANALOG_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYN5V2ANALOG_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYN5V2ANALOG_FLAG; /* clear txpSeverityN5v2Analog */
       /*
        * TODO:482:o: |-> commit column txpSeverityN5v2Analog.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityN5v2Analog commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityN5v2Analog
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYN5V2ANALOG_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYP3P3VANALOG_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYP3P3VANALOG_FLAG; /* clear txpSeverityP3p3vAnalog */
       /*
        * TODO:482:o: |-> commit column txpSeverityP3p3vAnalog.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityP3p3vAnalog commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityP3p3vAnalog
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYP3P3VANALOG_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYP3P3VDIGITAL_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYP3P3VDIGITAL_FLAG; /* clear txpSeverityP3p3vDigital */
       /*
        * TODO:482:o: |-> commit column txpSeverityP3p3vDigital.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityP3p3vDigital commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityP3p3vDigital
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYP3P3VDIGITAL_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYLVDIGITAL_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYLVDIGITAL_FLAG; /* clear txpSeverityLvDigital */
       /*
        * TODO:482:o: |-> commit column txpSeverityLvDigital.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityLvDigital commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityLvDigital
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYLVDIGITAL_FLAG;
       }
    }

    if (save_flags & COLUMN_TXPSEVERITYN5P2VDIGITAL_FLAG) {
       save_flags &= ~COLUMN_TXPSEVERITYN5P2VDIGITAL_FLAG; /* clear txpSeverityN5p2vDigital */
       /*
        * TODO:482:o: |-> commit column txpSeverityN5p2vDigital.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"txpSeverityTable column txpSeverityN5p2vDigital commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo txpSeverityN5p2vDigital
             */
            rowreq_ctx->column_set_flags |= COLUMN_TXPSEVERITYN5P2VDIGITAL_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* txpSeverityTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * txpSeverityTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param txpSeverityTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int txpSeverityTable_undo_commit( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
	DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTable_undo_commit","called\n"));

    int rc = MFD_SUCCESS;

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo txpSeverityTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* txpSeverityTable_undo_commit */

/*
 * TODO:440:M: Implement txpSeverityTable node value checks.
 * TODO:450:M: Implement txpSeverityTable undo functions.
 * TODO:460:M: Implement txpSeverityTable set functions.
 * TODO:480:M: Implement txpSeverityTable commit functions.
 */
/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityEol
 * txpSeverityEol is subid 2 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.2
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityEol_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityEol_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityEol_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityEol_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityEol value.
     */

    return MFD_SUCCESS; /* txpSeverityEol value not illegal */
} /* txpSeverityEol_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityEol_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityEol_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityEol undo.
     */
    /*
     * copy txpSeverityEol data
     * set rowreq_ctx->undo->txpSeverityEol from rowreq_ctx->data.txpSeverityEol
     */
    rowreq_ctx->undo->txpSeverityEol = rowreq_ctx->data.txpSeverityEol;


    return MFD_SUCCESS;
} /* txpSeverityEol_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityEol_val
 *        A long containing the new value.
 */
int txpSeverityEol_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityEol_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityEol_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityEol value.
     * set txpSeverityEol value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityEol = txpSeverityEol_val;

    // Set severity on shared memory
    setTxpSeverity("eol", txpSeverityEol_val);

    return MFD_SUCCESS;
} /* txpSeverityEol_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityEol_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityEol_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityEol undo.
     */
    /*
     * copy txpSeverityEol data
     * set rowreq_ctx->data.txpSeverityEol from rowreq_ctx->undo->txpSeverityEol
     */
    rowreq_ctx->data.txpSeverityEol = rowreq_ctx->undo->txpSeverityEol;

    
    return MFD_SUCCESS;
} /* txpSeverityEol_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityModTemp
 * txpSeverityModTemp is subid 3 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.3
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityModTemp_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityModTemp_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityModTemp_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityModTemp_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityModTemp value.
     */

    return MFD_SUCCESS; /* txpSeverityModTemp value not illegal */
} /* txpSeverityModTemp_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityModTemp_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityModTemp_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityModTemp undo.
     */
    /*
     * copy txpSeverityModTemp data
     * set rowreq_ctx->undo->txpSeverityModTemp from rowreq_ctx->data.txpSeverityModTemp
     */
    rowreq_ctx->undo->txpSeverityModTemp = rowreq_ctx->data.txpSeverityModTemp;


    return MFD_SUCCESS;
} /* txpSeverityModTemp_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityModTemp_val
 *        A long containing the new value.
 */
int txpSeverityModTemp_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityModTemp_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityModTemp_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityModTemp value.
     * set txpSeverityModTemp value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityModTemp = txpSeverityModTemp_val;

    // Set severity on shared memory
    setTxpSeverity("mod_temp", txpSeverityModTemp_val);

    return MFD_SUCCESS;
} /* txpSeverityModTemp_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityModTemp_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityModTemp_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityModTemp undo.
     */
    /*
     * copy txpSeverityModTemp data
     * set rowreq_ctx->data.txpSeverityModTemp from rowreq_ctx->undo->txpSeverityModTemp
     */
    rowreq_ctx->data.txpSeverityModTemp = rowreq_ctx->undo->txpSeverityModTemp;

    
    return MFD_SUCCESS;
} /* txpSeverityModTemp_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityTxooa
 * txpSeverityTxooa is subid 4 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.4
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityTxooa_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityTxooa_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityTxooa_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxooa_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityTxooa value.
     */

    return MFD_SUCCESS; /* txpSeverityTxooa value not illegal */
} /* txpSeverityTxooa_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityTxooa_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxooa_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityTxooa undo.
     */
    /*
     * copy txpSeverityTxooa data
     * set rowreq_ctx->undo->txpSeverityTxooa from rowreq_ctx->data.txpSeverityTxooa
     */
    rowreq_ctx->undo->txpSeverityTxooa = rowreq_ctx->data.txpSeverityTxooa;


    return MFD_SUCCESS;
} /* txpSeverityTxooa_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityTxooa_val
 *        A long containing the new value.
 */
int txpSeverityTxooa_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityTxooa_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxooa_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityTxooa value.
     * set txpSeverityTxooa value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityTxooa = txpSeverityTxooa_val;

    // Set severity on shared memory
    setTxpSeverity("txooa", txpSeverityTxooa_val);

    return MFD_SUCCESS;
} /* txpSeverityTxooa_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityTxooa_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxooa_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityTxooa undo.
     */
    /*
     * copy txpSeverityTxooa data
     * set rowreq_ctx->data.txpSeverityTxooa from rowreq_ctx->undo->txpSeverityTxooa
     */
    rowreq_ctx->data.txpSeverityTxooa = rowreq_ctx->undo->txpSeverityTxooa;

    
    return MFD_SUCCESS;
} /* txpSeverityTxooa_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityTxLof
 * txpSeverityTxLof is subid 5 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.5
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityTxLof_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityTxLof_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityTxLof_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxLof_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityTxLof value.
     */

    return MFD_SUCCESS; /* txpSeverityTxLof value not illegal */
} /* txpSeverityTxLof_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityTxLof_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxLof_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityTxLof undo.
     */
    /*
     * copy txpSeverityTxLof data
     * set rowreq_ctx->undo->txpSeverityTxLof from rowreq_ctx->data.txpSeverityTxLof
     */
    rowreq_ctx->undo->txpSeverityTxLof = rowreq_ctx->data.txpSeverityTxLof;


    return MFD_SUCCESS;
} /* txpSeverityTxLof_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityTxLof_val
 *        A long containing the new value.
 */
int txpSeverityTxLof_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityTxLof_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxLof_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityTxLof value.
     * set txpSeverityTxLof value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityTxLof = txpSeverityTxLof_val;

    // Set severity on shared memory
    setTxpSeverity("tx_lof", txpSeverityTxLof_val);

    return MFD_SUCCESS;
} /* txpSeverityTxLof_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityTxLof_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxLof_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityTxLof undo.
     */
    /*
     * copy txpSeverityTxLof data
     * set rowreq_ctx->data.txpSeverityTxLof from rowreq_ctx->undo->txpSeverityTxLof
     */
    rowreq_ctx->data.txpSeverityTxLof = rowreq_ctx->undo->txpSeverityTxLof;

    
    return MFD_SUCCESS;
} /* txpSeverityTxLof_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityTxDsc
 * txpSeverityTxDsc is subid 6 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.6
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityTxDsc_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityTxDsc_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityTxDsc_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxDsc_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityTxDsc value.
     */

    return MFD_SUCCESS; /* txpSeverityTxDsc value not illegal */
} /* txpSeverityTxDsc_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityTxDsc_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxDsc_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityTxDsc undo.
     */
    /*
     * copy txpSeverityTxDsc data
     * set rowreq_ctx->undo->txpSeverityTxDsc from rowreq_ctx->data.txpSeverityTxDsc
     */
    rowreq_ctx->undo->txpSeverityTxDsc = rowreq_ctx->data.txpSeverityTxDsc;


    return MFD_SUCCESS;
} /* txpSeverityTxDsc_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityTxDsc_val
 *        A long containing the new value.
 */
int txpSeverityTxDsc_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityTxDsc_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxDsc_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityTxDsc value.
     * set txpSeverityTxDsc value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityTxDsc = txpSeverityTxDsc_val;

    // Set severity on shared memory
    setTxpSeverity("tx_dsc", txpSeverityTxDsc_val);

    return MFD_SUCCESS;
} /* txpSeverityTxDsc_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityTxDsc_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxDsc_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityTxDsc undo.
     */
    /*
     * copy txpSeverityTxDsc data
     * set rowreq_ctx->data.txpSeverityTxDsc from rowreq_ctx->undo->txpSeverityTxDsc
     */
    rowreq_ctx->data.txpSeverityTxDsc = rowreq_ctx->undo->txpSeverityTxDsc;
    
    return MFD_SUCCESS;
} /* txpSeverityTxDsc_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityLsWav
 * txpSeverityLsWav is subid 7 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.7
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityLsWav_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityLsWav_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityLsWav_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsWav_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityLsWav value.
     */

    return MFD_SUCCESS; /* txpSeverityLsWav value not illegal */
} /* txpSeverityLsWav_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityLsWav_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsWav_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityLsWav undo.
     */
    /*
     * copy txpSeverityLsWav data
     * set rowreq_ctx->undo->txpSeverityLsWav from rowreq_ctx->data.txpSeverityLsWav
     */
    rowreq_ctx->undo->txpSeverityLsWav = rowreq_ctx->data.txpSeverityLsWav;


    return MFD_SUCCESS;
} /* txpSeverityLsWav_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityLsWav_val
 *        A long containing the new value.
 */
int txpSeverityLsWav_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityLsWav_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsWav_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityLsWav value.
     * set txpSeverityLsWav value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityLsWav = txpSeverityLsWav_val;

    // Set severity on shared memory
    setTxpSeverity("ls_wav", txpSeverityLsWav_val);

    return MFD_SUCCESS;
} /* txpSeverityLsWav_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityLsWav_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsWav_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityLsWav undo.
     */
    /*
     * copy txpSeverityLsWav data
     * set rowreq_ctx->data.txpSeverityLsWav from rowreq_ctx->undo->txpSeverityLsWav
     */
    rowreq_ctx->data.txpSeverityLsWav = rowreq_ctx->undo->txpSeverityLsWav;

    
    return MFD_SUCCESS;
} /* txpSeverityLsWav_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityLsBias
 * txpSeverityLsBias is subid 8 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.8
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityLsBias_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityLsBias_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityLsBias_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsBias_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityLsBias value.
     */

    return MFD_SUCCESS; /* txpSeverityLsBias value not illegal */
} /* txpSeverityLsBias_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityLsBias_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsBias_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityLsBias undo.
     */
    /*
     * copy txpSeverityLsBias data
     * set rowreq_ctx->undo->txpSeverityLsBias from rowreq_ctx->data.txpSeverityLsBias
     */
    rowreq_ctx->undo->txpSeverityLsBias = rowreq_ctx->data.txpSeverityLsBias;


    return MFD_SUCCESS;
} /* txpSeverityLsBias_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityLsBias_val
 *        A long containing the new value.
 */
int txpSeverityLsBias_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityLsBias_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsBias_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityLsBias value.
     * set txpSeverityLsBias value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityLsBias = txpSeverityLsBias_val;

    // Set severity on shared memory
    setTxpSeverity("ls_bias", txpSeverityLsBias_val);

    return MFD_SUCCESS;
} /* txpSeverityLsBias_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityLsBias_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsBias_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityLsBias undo.
     */
    /*
     * copy txpSeverityLsBias data
     * set rowreq_ctx->data.txpSeverityLsBias from rowreq_ctx->undo->txpSeverityLsBias
     */
    rowreq_ctx->data.txpSeverityLsBias = rowreq_ctx->undo->txpSeverityLsBias;

    
    return MFD_SUCCESS;
} /* txpSeverityLsBias_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityLsTemp
 * txpSeverityLsTemp is subid 9 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.9
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityLsTemp_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityLsTemp_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityLsTemp_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsTemp_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityLsTemp value.
     */

    return MFD_SUCCESS; /* txpSeverityLsTemp value not illegal */
} /* txpSeverityLsTemp_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityLsTemp_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsTemp_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityLsTemp undo.
     */
    /*
     * copy txpSeverityLsTemp data
     * set rowreq_ctx->undo->txpSeverityLsTemp from rowreq_ctx->data.txpSeverityLsTemp
     */
    rowreq_ctx->undo->txpSeverityLsTemp = rowreq_ctx->data.txpSeverityLsTemp;


    return MFD_SUCCESS;
} /* txpSeverityLsTemp_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityLsTemp_val
 *        A long containing the new value.
 */
int txpSeverityLsTemp_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityLsTemp_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsTemp_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityLsTemp value.
     * set txpSeverityLsTemp value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityLsTemp = txpSeverityLsTemp_val;

    // Set severity on shared memory
    setTxpSeverity("ls_temp", txpSeverityLsTemp_val);

    return MFD_SUCCESS;
} /* txpSeverityLsTemp_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityLsTemp_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsTemp_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityLsTemp undo.
     */
    /*
     * copy txpSeverityLsTemp data
     * set rowreq_ctx->data.txpSeverityLsTemp from rowreq_ctx->undo->txpSeverityLsTemp
     */
    rowreq_ctx->data.txpSeverityLsTemp = rowreq_ctx->undo->txpSeverityLsTemp;

    
    return MFD_SUCCESS;
} /* txpSeverityLsTemp_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityTxLock
 * txpSeverityTxLock is subid 10 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.10
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityTxLock_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityTxLock_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityTxLock_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxLock_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityTxLock value.
     */

    return MFD_SUCCESS; /* txpSeverityTxLock value not illegal */
} /* txpSeverityTxLock_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityTxLock_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxLock_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityTxLock undo.
     */
    /*
     * copy txpSeverityTxLock data
     * set rowreq_ctx->undo->txpSeverityTxLock from rowreq_ctx->data.txpSeverityTxLock
     */
    rowreq_ctx->undo->txpSeverityTxLock = rowreq_ctx->data.txpSeverityTxLock;


    return MFD_SUCCESS;
} /* txpSeverityTxLock_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityTxLock_val
 *        A long containing the new value.
 */
int txpSeverityTxLock_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityTxLock_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxLock_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityTxLock value.
     * set txpSeverityTxLock value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityTxLock = txpSeverityTxLock_val;

    // Set severity on shared memory
    setTxpSeverity("tx_lock", txpSeverityTxLock_val);

    return MFD_SUCCESS;
} /* txpSeverityTxLock_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityTxLock_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityTxLock_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityTxLock undo.
     */
    /*
     * copy txpSeverityTxLock data
     * set rowreq_ctx->data.txpSeverityTxLock from rowreq_ctx->undo->txpSeverityTxLock
     */
    rowreq_ctx->data.txpSeverityTxLock = rowreq_ctx->undo->txpSeverityTxLock;

    
    return MFD_SUCCESS;
} /* txpSeverityTxLock_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityLsPow
 * txpSeverityLsPow is subid 11 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.11
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityLsPow_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityLsPow_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityLsPow_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsPow_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityLsPow value.
     */

    return MFD_SUCCESS; /* txpSeverityLsPow value not illegal */
} /* txpSeverityLsPow_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityLsPow_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsPow_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityLsPow undo.
     */
    /*
     * copy txpSeverityLsPow data
     * set rowreq_ctx->undo->txpSeverityLsPow from rowreq_ctx->data.txpSeverityLsPow
     */
    rowreq_ctx->undo->txpSeverityLsPow = rowreq_ctx->data.txpSeverityLsPow;


    return MFD_SUCCESS;
} /* txpSeverityLsPow_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityLsPow_val
 *        A long containing the new value.
 */
int txpSeverityLsPow_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityLsPow_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsPow_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityLsPow value.
     * set txpSeverityLsPow value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityLsPow = txpSeverityLsPow_val;

    // Set severity on shared memory
    setTxpSeverity("ls_pow", txpSeverityLsPow_val);

    return MFD_SUCCESS;
} /* txpSeverityLsPow_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityLsPow_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLsPow_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityLsPow undo.
     */
    /*
     * copy txpSeverityLsPow data
     * set rowreq_ctx->data.txpSeverityLsPow from rowreq_ctx->undo->txpSeverityLsPow
     */
    rowreq_ctx->data.txpSeverityLsPow = rowreq_ctx->undo->txpSeverityLsPow;

    
    return MFD_SUCCESS;
} /* txpSeverityLsPow_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityModBias
 * txpSeverityModBias is subid 12 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.12
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityModBias_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityModBias_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityModBias_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityModBias_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityModBias value.
     */

    return MFD_SUCCESS; /* txpSeverityModBias value not illegal */
} /* txpSeverityModBias_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityModBias_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityModBias_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityModBias undo.
     */
    /*
     * copy txpSeverityModBias data
     * set rowreq_ctx->undo->txpSeverityModBias from rowreq_ctx->data.txpSeverityModBias
     */
    rowreq_ctx->undo->txpSeverityModBias = rowreq_ctx->data.txpSeverityModBias;


    return MFD_SUCCESS;
} /* txpSeverityModBias_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityModBias_val
 *        A long containing the new value.
 */
int txpSeverityModBias_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityModBias_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityModBias_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityModBias value.
     * set txpSeverityModBias value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityModBias = txpSeverityModBias_val;

    // Set severity on shared memory
    setTxpSeverity("mod_bias", txpSeverityModBias_val);

    return MFD_SUCCESS;
} /* txpSeverityModBias_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityModBias_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityModBias_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityModBias undo.
     */
    /*
     * copy txpSeverityModBias data
     * set rowreq_ctx->data.txpSeverityModBias from rowreq_ctx->undo->txpSeverityModBias
     */
    rowreq_ctx->data.txpSeverityModBias = rowreq_ctx->undo->txpSeverityModBias;

    
    return MFD_SUCCESS;
} /* txpSeverityModBias_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityLatchedTxFifo
 * txpSeverityLatchedTxFifo is subid 13 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.13
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityLatchedTxFifo_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityLatchedTxFifo_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityLatchedTxFifo_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLatchedTxFifo_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityLatchedTxFifo value.
     */

    return MFD_SUCCESS; /* txpSeverityLatchedTxFifo value not illegal */
} /* txpSeverityLatchedTxFifo_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityLatchedTxFifo_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLatchedTxFifo_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityLatchedTxFifo undo.
     */
    /*
     * copy txpSeverityLatchedTxFifo data
     * set rowreq_ctx->undo->txpSeverityLatchedTxFifo from rowreq_ctx->data.txpSeverityLatchedTxFifo
     */
    rowreq_ctx->undo->txpSeverityLatchedTxFifo = rowreq_ctx->data.txpSeverityLatchedTxFifo;


    return MFD_SUCCESS;
} /* txpSeverityLatchedTxFifo_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityLatchedTxFifo_val
 *        A long containing the new value.
 */
int txpSeverityLatchedTxFifo_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityLatchedTxFifo_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLatchedTxFifo_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityLatchedTxFifo value.
     * set txpSeverityLatchedTxFifo value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityLatchedTxFifo = txpSeverityLatchedTxFifo_val;

    // Set severity on shared memory
    setTxpSeverity("latched_tx_fifo", txpSeverityLatchedTxFifo_val);

    return MFD_SUCCESS;
} /* txpSeverityLatchedTxFifo_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityLatchedTxFifo_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLatchedTxFifo_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityLatchedTxFifo undo.
     */
    /*
     * copy txpSeverityLatchedTxFifo data
     * set rowreq_ctx->data.txpSeverityLatchedTxFifo from rowreq_ctx->undo->txpSeverityLatchedTxFifo
     */
    rowreq_ctx->data.txpSeverityLatchedTxFifo = rowreq_ctx->undo->txpSeverityLatchedTxFifo;

    
    return MFD_SUCCESS;
} /* txpSeverityLatchedTxFifo_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityRxPow
 * txpSeverityRxPow is subid 14 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.14
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityRxPow_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityRxPow_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityRxPow_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxPow_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityRxPow value.
     */

    return MFD_SUCCESS; /* txpSeverityRxPow value not illegal */
} /* txpSeverityRxPow_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityRxPow_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxPow_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityRxPow undo.
     */
    /*
     * copy txpSeverityRxPow data
     * set rowreq_ctx->undo->txpSeverityRxPow from rowreq_ctx->data.txpSeverityRxPow
     */
    rowreq_ctx->undo->txpSeverityRxPow = rowreq_ctx->data.txpSeverityRxPow;

    return MFD_SUCCESS;
} /* txpSeverityRxPow_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityRxPow_val
 *        A long containing the new value.
 */
int txpSeverityRxPow_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityRxPow_val )
{

    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxPow_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityRxPow value.
     * set txpSeverityRxPow value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityRxPow = txpSeverityRxPow_val;

    // Set severity on shared memory
     setTxpSeverity("rx_pow", txpSeverityRxPow_val);

    return MFD_SUCCESS;
} /* txpSeverityRxPow_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityRxPow_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxPow_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityRxPow undo.
     */
    /*
     * copy txpSeverityRxPow data
     * set rowreq_ctx->data.txpSeverityRxPow from rowreq_ctx->undo->txpSeverityRxPow
     */
    rowreq_ctx->data.txpSeverityRxPow = rowreq_ctx->undo->txpSeverityRxPow;

    
    return MFD_SUCCESS;
} /* txpSeverityRxPow_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityRxLos
 * txpSeverityRxLos is subid 15 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.15
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityRxLos_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityRxLos_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityRxLos_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxLos_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityRxLos value.
     */

    return MFD_SUCCESS; /* txpSeverityRxLos value not illegal */
} /* txpSeverityRxLos_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityRxLos_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxLos_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityRxLos undo.
     */
    /*
     * copy txpSeverityRxLos data
     * set rowreq_ctx->undo->txpSeverityRxLos from rowreq_ctx->data.txpSeverityRxLos
     */
    rowreq_ctx->undo->txpSeverityRxLos = rowreq_ctx->data.txpSeverityRxLos;


    return MFD_SUCCESS;
} /* txpSeverityRxLos_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityRxLos_val
 *        A long containing the new value.
 */
int txpSeverityRxLos_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityRxLos_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxLos_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityRxLos value.
     * set txpSeverityRxLos value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityRxLos = txpSeverityRxLos_val;

    // Set severity on shared memory
    setTxpSeverity("rx_los", txpSeverityRxLos_val);

    return MFD_SUCCESS;
} /* txpSeverityRxLos_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityRxLos_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxLos_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityRxLos undo.
     */
    /*
     * copy txpSeverityRxLos data
     * set rowreq_ctx->data.txpSeverityRxLos from rowreq_ctx->undo->txpSeverityRxLos
     */
    rowreq_ctx->data.txpSeverityRxLos = rowreq_ctx->undo->txpSeverityRxLos;

    
    return MFD_SUCCESS;
} /* txpSeverityRxLos_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityRxLock
 * txpSeverityRxLock is subid 16 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.16
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityRxLock_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityRxLock_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityRxLock_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxLock_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityRxLock value.
     */

    return MFD_SUCCESS; /* txpSeverityRxLock value not illegal */
} /* txpSeverityRxLock_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityRxLock_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxLock_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityRxLock undo.
     */
    /*
     * copy txpSeverityRxLock data
     * set rowreq_ctx->undo->txpSeverityRxLock from rowreq_ctx->data.txpSeverityRxLock
     */
    rowreq_ctx->undo->txpSeverityRxLock = rowreq_ctx->data.txpSeverityRxLock;


    return MFD_SUCCESS;
} /* txpSeverityRxLock_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityRxLock_val
 *        A long containing the new value.
 */
int txpSeverityRxLock_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityRxLock_val )
{

    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxLock_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityRxLock value.
     * set txpSeverityRxLock value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityRxLock = txpSeverityRxLock_val;

    // Set severity on shared memory
    setTxpSeverity("rx_lock", txpSeverityRxLock_val);

    return MFD_SUCCESS;
} /* txpSeverityRxLock_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityRxLock_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxLock_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityRxLock undo.
     */
    /*
     * copy txpSeverityRxLock data
     * set rowreq_ctx->data.txpSeverityRxLock from rowreq_ctx->undo->txpSeverityRxLock
     */
    rowreq_ctx->data.txpSeverityRxLock = rowreq_ctx->undo->txpSeverityRxLock;
    
    return MFD_SUCCESS;
} /* txpSeverityRxLock_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityRxs
 * txpSeverityRxs is subid 17 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.17
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityRxs_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityRxs_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityRxs_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxs_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityRxs value.
     */

    return MFD_SUCCESS; /* txpSeverityRxs value not illegal */
} /* txpSeverityRxs_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityRxs_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxs_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityRxs undo.
     */
    /*
     * copy txpSeverityRxs data
     * set rowreq_ctx->undo->txpSeverityRxs from rowreq_ctx->data.txpSeverityRxs
     */
    rowreq_ctx->undo->txpSeverityRxs = rowreq_ctx->data.txpSeverityRxs;


    return MFD_SUCCESS;
} /* txpSeverityRxs_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityRxs_val
 *        A long containing the new value.
 */
int txpSeverityRxs_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityRxs_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxs_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityRxs value.
     * set txpSeverityRxs value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityRxs = txpSeverityRxs_val;

    // Set severity on shared memory
    setTxpSeverity("rxs", txpSeverityRxs_val);

    return MFD_SUCCESS;
} /* txpSeverityRxs_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityRxs_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityRxs_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityRxs undo.
     */
    /*
     * copy txpSeverityRxs data
     * set rowreq_ctx->data.txpSeverityRxs from rowreq_ctx->undo->txpSeverityRxs
     */
    rowreq_ctx->data.txpSeverityRxs = rowreq_ctx->undo->txpSeverityRxs;

    
    return MFD_SUCCESS;
} /* txpSeverityRxs_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityPrbsErr
 * txpSeverityPrbsErr is subid 18 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.18
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityPrbsErr_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityPrbsErr_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityPrbsErr_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityPrbsErr_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityPrbsErr value.
     */

    return MFD_SUCCESS; /* txpSeverityPrbsErr value not illegal */
} /* txpSeverityPrbsErr_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityPrbsErr_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityPrbsErr_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityPrbsErr undo.
     */
    /*
     * copy txpSeverityPrbsErr data
     * set rowreq_ctx->undo->txpSeverityPrbsErr from rowreq_ctx->data.txpSeverityPrbsErr
     */
    rowreq_ctx->undo->txpSeverityPrbsErr = rowreq_ctx->data.txpSeverityPrbsErr;


    return MFD_SUCCESS;
} /* txpSeverityPrbsErr_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityPrbsErr_val
 *        A long containing the new value.
 */
int txpSeverityPrbsErr_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityPrbsErr_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityPrbsErr_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityPrbsErr value.
     * set txpSeverityPrbsErr value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityPrbsErr = txpSeverityPrbsErr_val;

    // Set severity on shared memory
    setTxpSeverity("prbs_err", txpSeverityPrbsErr_val);

    return MFD_SUCCESS;
} /* txpSeverityPrbsErr_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityPrbsErr_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityPrbsErr_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityPrbsErr undo.
     */
    /*
     * copy txpSeverityPrbsErr data
     * set rowreq_ctx->data.txpSeverityPrbsErr from rowreq_ctx->undo->txpSeverityPrbsErr
     */
    rowreq_ctx->data.txpSeverityPrbsErr = rowreq_ctx->undo->txpSeverityPrbsErr;

    
    return MFD_SUCCESS;
} /* txpSeverityPrbsErr_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityPsummary
 * txpSeverityPsummary is subid 19 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.19
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityPsummary_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityPsummary_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityPsummary_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityPsummary_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityPsummary value.
     */

    return MFD_SUCCESS; /* txpSeverityPsummary value not illegal */
} /* txpSeverityPsummary_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityPsummary_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityPsummary_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityPsummary undo.
     */
    /*
     * copy txpSeverityPsummary data
     * set rowreq_ctx->undo->txpSeverityPsummary from rowreq_ctx->data.txpSeverityPsummary
     */
    rowreq_ctx->undo->txpSeverityPsummary = rowreq_ctx->data.txpSeverityPsummary;

    return MFD_SUCCESS;
} /* txpSeverityPsummary_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityPsummary_val
 *        A long containing the new value.
 */
int txpSeverityPsummary_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityPsummary_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityPsummary_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityPsummary value.
     * set txpSeverityPsummary value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityPsummary = txpSeverityPsummary_val;

    // Set severity on shared memory
    setTxpSeverity("psummary", txpSeverityPsummary_val);

    return MFD_SUCCESS;
} /* txpSeverityPsummary_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityPsummary_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityPsummary_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityPsummary undo.
     */
    /*
     * copy txpSeverityPsummary data
     * set rowreq_ctx->data.txpSeverityPsummary from rowreq_ctx->undo->txpSeverityPsummary
     */
    rowreq_ctx->data.txpSeverityPsummary = rowreq_ctx->undo->txpSeverityPsummary;
    
    return MFD_SUCCESS;
} /* txpSeverityPsummary_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityP5vAnalog
 * txpSeverityP5vAnalog is subid 20 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.20
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityP5vAnalog_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityP5vAnalog_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityP5vAnalog_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityP5vAnalog_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityP5vAnalog value.
     */

    return MFD_SUCCESS; /* txpSeverityP5vAnalog value not illegal */
} /* txpSeverityP5vAnalog_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityP5vAnalog_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityP5vAnalog_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityP5vAnalog undo.
     */
    /*
     * copy txpSeverityP5vAnalog data
     * set rowreq_ctx->undo->txpSeverityP5vAnalog from rowreq_ctx->data.txpSeverityP5vAnalog
     */
    rowreq_ctx->undo->txpSeverityP5vAnalog = rowreq_ctx->data.txpSeverityP5vAnalog;

    return MFD_SUCCESS;
} /* txpSeverityP5vAnalog_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityP5vAnalog_val
 *        A long containing the new value.
 */
int txpSeverityP5vAnalog_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityP5vAnalog_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityP5vAnalog_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityP5vAnalog value.
     * set txpSeverityP5vAnalog value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityP5vAnalog = txpSeverityP5vAnalog_val;

    // Set severity on shared memory
    setTxpSeverity("p5vanalog", txpSeverityP5vAnalog_val);

    return MFD_SUCCESS;
} /* txpSeverityP5vAnalog_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityP5vAnalog_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityP5vAnalog_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityP5vAnalog undo.
     */
    /*
     * copy txpSeverityP5vAnalog data
     * set rowreq_ctx->data.txpSeverityP5vAnalog from rowreq_ctx->undo->txpSeverityP5vAnalog
     */
    rowreq_ctx->data.txpSeverityP5vAnalog = rowreq_ctx->undo->txpSeverityP5vAnalog;

    
    return MFD_SUCCESS;
} /* txpSeverityP5vAnalog_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityN5v2Analog
 * txpSeverityN5v2Analog is subid 21 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.21
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityN5v2Analog_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityN5v2Analog_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityN5v2Analog_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityN5v2Analog_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityN5v2Analog value.
     */

    return MFD_SUCCESS; /* txpSeverityN5v2Analog value not illegal */
} /* txpSeverityN5v2Analog_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityN5v2Analog_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityN5v2Analog_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityN5v2Analog undo.
     */
    /*
     * copy txpSeverityN5v2Analog data
     * set rowreq_ctx->undo->txpSeverityN5v2Analog from rowreq_ctx->data.txpSeverityN5v2Analog
     */
    rowreq_ctx->undo->txpSeverityN5v2Analog = rowreq_ctx->data.txpSeverityN5v2Analog;


    return MFD_SUCCESS;
} /* txpSeverityN5v2Analog_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityN5v2Analog_val
 *        A long containing the new value.
 */
int txpSeverityN5v2Analog_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityN5v2Analog_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityN5v2Analog_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityN5v2Analog value.
     * set txpSeverityN5v2Analog value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityN5v2Analog = txpSeverityN5v2Analog_val;

    // Set severity on shared memory
    setTxpSeverity("n5v2analog", txpSeverityN5v2Analog_val);

    return MFD_SUCCESS;
} /* txpSeverityN5v2Analog_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityN5v2Analog_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityN5v2Analog_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityN5v2Analog undo.
     */
    /*
     * copy txpSeverityN5v2Analog data
     * set rowreq_ctx->data.txpSeverityN5v2Analog from rowreq_ctx->undo->txpSeverityN5v2Analog
     */
    rowreq_ctx->data.txpSeverityN5v2Analog = rowreq_ctx->undo->txpSeverityN5v2Analog;
    
    return MFD_SUCCESS;
} /* txpSeverityN5v2Analog_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityP3p3vAnalog
 * txpSeverityP3p3vAnalog is subid 22 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.22
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityP3p3vAnalog_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityP3p3vAnalog_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityP3p3vAnalog_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityP3p3vAnalog_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityP3p3vAnalog value.
     */

    return MFD_SUCCESS; /* txpSeverityP3p3vAnalog value not illegal */
} /* txpSeverityP3p3vAnalog_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityP3p3vAnalog_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityP3p3vAnalog_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityP3p3vAnalog undo.
     */
    /*
     * copy txpSeverityP3p3vAnalog data
     * set rowreq_ctx->undo->txpSeverityP3p3vAnalog from rowreq_ctx->data.txpSeverityP3p3vAnalog
     */
    rowreq_ctx->undo->txpSeverityP3p3vAnalog = rowreq_ctx->data.txpSeverityP3p3vAnalog;


    return MFD_SUCCESS;
} /* txpSeverityP3p3vAnalog_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityP3p3vAnalog_val
 *        A long containing the new value.
 */
int txpSeverityP3p3vAnalog_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityP3p3vAnalog_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityP3p3vAnalog_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityP3p3vAnalog value.
     * set txpSeverityP3p3vAnalog value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityP3p3vAnalog = txpSeverityP3p3vAnalog_val;

    // Set severity on shared memory
    setTxpSeverity("p3p3vanalog", txpSeverityP3p3vAnalog_val);

    return MFD_SUCCESS;
} /* txpSeverityP3p3vAnalog_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityP3p3vAnalog_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityP3p3vAnalog_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityP3p3vAnalog undo.
     */
    /*
     * copy txpSeverityP3p3vAnalog data
     * set rowreq_ctx->data.txpSeverityP3p3vAnalog from rowreq_ctx->undo->txpSeverityP3p3vAnalog
     */
    rowreq_ctx->data.txpSeverityP3p3vAnalog = rowreq_ctx->undo->txpSeverityP3p3vAnalog;
    
    return MFD_SUCCESS;
} /* txpSeverityP3p3vAnalog_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityP3p3vDigital
 * txpSeverityP3p3vDigital is subid 23 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.23
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityP3p3vDigital_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityP3p3vDigital_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityP3p3vDigital_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityP3p3vDigital_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityP3p3vDigital value.
     */

    return MFD_SUCCESS; /* txpSeverityP3p3vDigital value not illegal */
} /* txpSeverityP3p3vDigital_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityP3p3vDigital_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityP3p3vDigital_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityP3p3vDigital undo.
     */
    /*
     * copy txpSeverityP3p3vDigital data
     * set rowreq_ctx->undo->txpSeverityP3p3vDigital from rowreq_ctx->data.txpSeverityP3p3vDigital
     */
    rowreq_ctx->undo->txpSeverityP3p3vDigital = rowreq_ctx->data.txpSeverityP3p3vDigital;

    return MFD_SUCCESS;
} /* txpSeverityP3p3vDigital_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityP3p3vDigital_val
 *        A long containing the new value.
 */
int txpSeverityP3p3vDigital_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityP3p3vDigital_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityP3p3vDigital_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityP3p3vDigital value.
     * set txpSeverityP3p3vDigital value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityP3p3vDigital = txpSeverityP3p3vDigital_val;

    // Set severity on shared memory
    setTxpSeverity("p3p3vdigital", txpSeverityP3p3vDigital_val);

    return MFD_SUCCESS;
} /* txpSeverityP3p3vDigital_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityP3p3vDigital_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityP3p3vDigital_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityP3p3vDigital undo.
     */
    /*
     * copy txpSeverityP3p3vDigital data
     * set rowreq_ctx->data.txpSeverityP3p3vDigital from rowreq_ctx->undo->txpSeverityP3p3vDigital
     */
    rowreq_ctx->data.txpSeverityP3p3vDigital = rowreq_ctx->undo->txpSeverityP3p3vDigital;
    
    return MFD_SUCCESS;
} /* txpSeverityP3p3vDigital_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityLvDigital
 * txpSeverityLvDigital is subid 24 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.24
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityLvDigital_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityLvDigital_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityLvDigital_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLvDigital_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityLvDigital value.
     */

    return MFD_SUCCESS; /* txpSeverityLvDigital value not illegal */
} /* txpSeverityLvDigital_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityLvDigital_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLvDigital_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityLvDigital undo.
     */
    /*
     * copy txpSeverityLvDigital data
     * set rowreq_ctx->undo->txpSeverityLvDigital from rowreq_ctx->data.txpSeverityLvDigital
     */
    rowreq_ctx->undo->txpSeverityLvDigital = rowreq_ctx->data.txpSeverityLvDigital;

    return MFD_SUCCESS;
} /* txpSeverityLvDigital_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityLvDigital_val
 *        A long containing the new value.
 */
int txpSeverityLvDigital_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityLvDigital_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLvDigital_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityLvDigital value.
     * set txpSeverityLvDigital value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityLvDigital = txpSeverityLvDigital_val;

    // Set severity on shared memory
    setTxpSeverity("lvdigital", txpSeverityLvDigital_val);

    return MFD_SUCCESS;
} /* txpSeverityLvDigital_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityLvDigital_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityLvDigital_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityLvDigital undo.
     */
    /*
     * copy txpSeverityLvDigital data
     * set rowreq_ctx->data.txpSeverityLvDigital from rowreq_ctx->undo->txpSeverityLvDigital
     */
    rowreq_ctx->data.txpSeverityLvDigital = rowreq_ctx->undo->txpSeverityLvDigital;
    
    return MFD_SUCCESS;
} /* txpSeverityLvDigital_undo */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpSeverityEntry.txpSeverityN5p2vDigital
 * txpSeverityN5p2vDigital is subid 25 of txpSeverityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.43484.1.1.3.4.1.1.25
 * Description:
alarm severity
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txpSeverityN5p2vDigital_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * txpSeverityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int txpSeverityN5p2vDigital_check_value( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityN5p2vDigital_val)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityN5p2vDigital_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid txpSeverityN5p2vDigital value.
     */

    return MFD_SUCCESS; /* txpSeverityN5p2vDigital value not illegal */
} /* txpSeverityN5p2vDigital_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (txpSeverityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * txpSeverityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int txpSeverityN5p2vDigital_undo_setup( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityN5p2vDigital_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup txpSeverityN5p2vDigital undo.
     */
    /*
     * copy txpSeverityN5p2vDigital data
     * set rowreq_ctx->undo->txpSeverityN5p2vDigital from rowreq_ctx->data.txpSeverityN5p2vDigital
     */
    rowreq_ctx->undo->txpSeverityN5p2vDigital = rowreq_ctx->data.txpSeverityN5p2vDigital;

    return MFD_SUCCESS;
} /* txpSeverityN5p2vDigital_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param txpSeverityN5p2vDigital_val
 *        A long containing the new value.
 */
int txpSeverityN5p2vDigital_set( txpSeverityTable_rowreq_ctx *rowreq_ctx, long txpSeverityN5p2vDigital_val )
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityN5p2vDigital_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set txpSeverityN5p2vDigital value.
     * set txpSeverityN5p2vDigital value in rowreq_ctx->data
     */
    rowreq_ctx->data.txpSeverityN5p2vDigital = txpSeverityN5p2vDigital_val;

    // Set severity on shared memory
    setTxpSeverity("n5p2vdigital", txpSeverityN5p2vDigital_val);

    return MFD_SUCCESS;
} /* txpSeverityN5p2vDigital_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int txpSeverityN5p2vDigital_undo( txpSeverityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:txpSeverityTable:txpSeverityN5p2vDigital_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up txpSeverityN5p2vDigital undo.
     */
    /*
     * copy txpSeverityN5p2vDigital data
     * set rowreq_ctx->data.txpSeverityN5p2vDigital from rowreq_ctx->undo->txpSeverityN5p2vDigital
     */
    rowreq_ctx->data.txpSeverityN5p2vDigital = rowreq_ctx->undo->txpSeverityN5p2vDigital;

    
    return MFD_SUCCESS;
} /* txpSeverityN5p2vDigital_undo */

void setTxpSeverity(char *alarm, long severity_value)
{
	DEBUGMSGTL(("verbose:txpSeverityTable:setTxpSeverity","called\n"));

	shm_handler_create(pt_monitor_struct);

	if(strcmp(alarm, "eol") == 0)
	{
		pt_monitor_struct->txp_struct.severity.eol = severity_value;
	}
	else if(strcmp(alarm, "mod_temp") == 0)
	{
		pt_monitor_struct->txp_struct.severity.mod_temp = severity_value;
	}
	else if(strcmp(alarm, "txooa") == 0)
	{
		pt_monitor_struct->txp_struct.severity.txooa = severity_value;
	}
	else if(strcmp(alarm, "tx_lof") == 0)
	{
		pt_monitor_struct->txp_struct.severity.tx_lof = severity_value;
	}
	else if(strcmp(alarm, "tx_dsc") == 0)
	{
		pt_monitor_struct->txp_struct.severity.tx_dsc = severity_value;
	}
	else if(strcmp(alarm, "ls_wav") == 0)
	{
		pt_monitor_struct->txp_struct.severity.ls_wav = severity_value;
	}
	else if(strcmp(alarm, "ls_bias") == 0)
	{
		pt_monitor_struct->txp_struct.severity.ls_bias = severity_value;
	}
	else if(strcmp(alarm, "ls_temp") == 0)
	{
		pt_monitor_struct->txp_struct.severity.ls_temp = severity_value;
	}
	else if(strcmp(alarm, "tx_lock") == 0)
	{
		pt_monitor_struct->txp_struct.severity.tx_lock = severity_value;
	}
	else if(strcmp(alarm, "ls_pow") == 0)
	{
		pt_monitor_struct->txp_struct.severity.ls_pow = severity_value;
	}
	else if(strcmp(alarm, "mod_bias") == 0)
	{
		pt_monitor_struct->txp_struct.severity.mod_bias = severity_value;
	}
	else if(strcmp(alarm, "latched_tx_fifo") == 0)
	{
		pt_monitor_struct->txp_struct.severity.latched_tx_fifo = severity_value;
	}
	else if(strcmp(alarm, "rx_pow") == 0)
	{
		pt_monitor_struct->txp_struct.severity.rx_pow = severity_value;
	}
	else if(strcmp(alarm, "rx_lock") == 0)
	{
		pt_monitor_struct->txp_struct.severity.rx_lock = severity_value;
	}
	else if(strcmp(alarm, "rxs") == 0)
	{
		pt_monitor_struct->txp_struct.severity.rxs = severity_value;
	}
	else if(strcmp(alarm, "prbs_err") == 0)
	{
		pt_monitor_struct->txp_struct.severity.prbs_err = severity_value;
	}
	else if(strcmp(alarm, "psummary") == 0)
	{
		pt_monitor_struct->txp_struct.severity.psummary = severity_value;
	}
	else if(strcmp(alarm, "p5vanalog") == 0)
	{
		pt_monitor_struct->txp_struct.severity.p5vanalog = severity_value;
	}
	else if(strcmp(alarm, "n5v2analog") == 0)
	{
		pt_monitor_struct->txp_struct.severity.n5v2analog = severity_value;
	}
	else if(strcmp(alarm, "p3p3vanalog") == 0)
	{
		pt_monitor_struct->txp_struct.severity.p3p3vanalog = severity_value;
	}
	else if(strcmp(alarm, "p3p3vdigital") == 0)
	{
		pt_monitor_struct->txp_struct.severity.p3p3vdigital = severity_value;
	}
	else if(strcmp(alarm, "lvdigital") == 0)
	{
		pt_monitor_struct->txp_struct.severity.lvdigital = severity_value;
	}
	else if(strcmp(alarm, "n5p2vdigital") == 0)
	{
		pt_monitor_struct->txp_struct.severity.n5p2vdigital = severity_value;
	}

	// Set dirty flag
	pt_monitor_struct->sev_dirty_flag = 1;
}

/** @} */
