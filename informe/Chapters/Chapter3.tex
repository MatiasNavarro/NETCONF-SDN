% Chapter Template 
% cSpell: words Mininet prototipado parencite enrutamiento includegraphics veth  mininetonf cellcolor Nicira vswitchd interconectar multicapa datapath ovsflow resizebox flowtable netlink OVSDB dpctl ofctl vsctl rowcolor mininetovs
 
\chapter{Análisis de las tecnologías} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

En base a los conceptos revisados en el capítulo anterior, en este se introducirá a las herramientas más representativas que permitirán la implementación de estos entornos. Como se menciona anteriormente, las redes definidas por software separan el plano de control de un dispositivo de red, del plano de datos, permitiendo controlar, monitorear y gestionar una red desde un nodo centralizado o controlador. Esto, en un principio nos da la pauta de que serán necesarias al menos dos entidades para realizar esta implementación.

En la primera sección se realizará un análisis de un ambiente de emulación del plano de datos, a través de la herramienta Mininet. Esta herramienta explota capacidades de virtualización del \textit{kernel} de Linux brindando la capacidad de emular \textit{hosts}, \textit{switches} y \textit{routers}.

Luego en la segunda sección, se consideran las opciones para la implementación del plano de control. En este caso el mercado es mucho más amplio y existen varias alternativas. A la hora de un análisis más detallado, se considerarán dos controladores OpenDaylight y ONOS. El criterio de selección de los mismos reside en que son los más utilizados en el mercado actualmente y son soluciones de código abierto.

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Emulador de red Mininet}

Para probar el rendimiento de la tecnología, es necesario que exista un entorno de verificación versátil, y con dispositivos que soporten Openflow, el protocolo de comunicación entre el plano de datos y control. Por estas razones, se descarta la construcción de un banco de pruebas íntegramente físico, para perfilarse ante un entorno de emulación, como lo es Mininet.

Provee una manera sencilla de crear redes definidas por software, las cuales consisten en un controlador, un grupo de \textit{switches} que soportan Openflow y múltiples \textit{hosts} conectados a estos \textit{switches}. Es utilizado en múltiples ámbitos tales como investigación, desarrollo, aprendizaje, prototipado, testing y otras tareas que requieran una red completa experimental dentro de cualquier PC. Soporta diferentes tipos de controladores y \textit{switches}, contiene una librería de topologías por defecto y permite también crear topologías más complejas a través de una API de \textit{Python}.

Mininet fue desarrollado en un principio por la universidad de Stanford, y actualmente se encuentra promovida por la ONF. Es una aplicación de código abierto y escrita principalmente en \textit{Python} y \textit{C}, basa su funcionamiento en los conceptos de: \textit{Linux Namespaces} \ref{subs:ns}, para la creación de \textit{hosts} aislados; \textit{Linux Traffic Control} \parencite{ltc}, para establecer enlaces emulados y \textit{Open vSwitch} \ref{subs:ovs}, para implementar \textit{switches} emulados.


\begin{figure}[th]
	\centering 
	\resizebox{0.75\textwidth}{!}{\includegraphics{Figures/mininet.png}}
	\caption[Diagrama de Mininet]{Las topologías de Mininet permiten la utilización de las aplicaciones de red de Linux/Unix en entornos aislados llamados \textit{Network namespaces}, dentro de un mismo kernel \parencite{mininetonf}.}
	\label{fig:mininet}
\end{figure}


\subsection{Linux network namespaces}
\label{subs:ns}
Un \textit{namespace} es una característica del kernel que permite aislar y virtualizar diferentes recursos del sistema. Existen diferentes tipos de \textit{namespaces}, diferenciados por el tipo de recursos que permiten virtualizar. Esta tecnología establece las bases de la virtualización a nivel de sistema operativo, también conocida como \textit{containerization}. 

Mininet utiliza \textit{network namespaces} los cuales posibilitan crear grupos de recursos de red aislados entre sí. Entre estos recursos encontramos, interfaces de red, tablas de enrutamiento, lista de sockets, \textit{firewall} y otras características relacionadas a las funciones de red. Luego, a través de \textit{virtual ethernet (veth)} es posible asignarle interfaces virtuales a los namespaces, de manera que estos puedan conectarse y emular enlaces, posibilitando así la emulación de los dispositivos, minimizando la sobrecarga y la complejidad en la virtualización de recursos de red.


\subsection{Open vSwitch}
\label{subs:ovs}
\textit{Open vSwitch} es un software desarrollado por Nicira, de código abierto y consiste en un \textit{switch} virtual multicapa. Nace como solución a la necesidad de interconectar máquinas virtuales en uno o más nodos físicos, permitiendo la creación de interfaces virtuales. Si bien el desarrollo de OvS se basa en \textit{linux bridges}, presenta un diseño mucho más complejo, ya que se encuentra compuesto por varios módulos. Mientras que los bridges se ejecutan solo en el espacio de kernel del \textit{host}, OvS se ejecuta también en el espacio de usuario, brindándole funcionalidades más avanzadas, como por ejemplo la capacidad de procesar paquetes desconocidos.

\begin{figure}[th]
	\centering 
	\resizebox{0.75\textwidth}{!}{\includegraphics{Figures/ovs.png}}
	\caption[Flujo del procesamiento de un paquete en un Open vSwitch]{Flujo del procesamiento de un paquete en un Open vSwitch \parencite{ovsflow}.}
	\label{fig:ovs}
\end{figure}

En la figura \ref{fig:ovs} se puede ver la arquitectura de un OvS, a continuación, se describirá brevemente el funcionamiento de los principales elementos que lo componen.
\begin{itemize}
	\item \textbf{Datapath}: representa al módulo del kernel que lleva a cabo el intercambio de paquetes, utiliza una memoria caché (\textit{flowtable}) en la que están descriptas las reglas a seguir con los paquetes entrantes. Cuando llega un paquete no reconocido, que no está en las tablas, el modulo se contactara con el proceso \textit{ovs-vswitchd} por medio de un \textit{netlink} para determinar su destino.
	\item \textbf{ovs-vswitchd}: es un demonio que implementa las principales funcionalidades del \textit{switch}. Se encarga de procesar los paquetes Openflow, mediante netlink se comunica con el datapath y realiza consulta y cambios en la base de datos a través del protocolo OVSDB.
	\item \textbf{ovsdb-server}: es un servidor de base de datos ligero que guarda las principales configuraciones de los elementos del \textit{switch}.
	\item \textbf{ovs-dpctl}: es la herramienta utilizada para configurar el modulo del kernel del \textit{switch}, obtener información exacta sobre los \textit{match} en la memoria caché
	\item \textbf{ovs-ofctl}: es una herramienta para monitorear y administrar las características Openflow del \textit{switch}, y poder ver los flujos en caché.
	\item \textbf{ovsdb-tool}: permite administrar la base de datos.
	\item \textbf{ovs-vsctl}: este comando es utilizado para configurar y obtener información del \textit{ovs-vswitchd}.
\end{itemize}

Los últimos cuatro ítems constituyen el principal medio de administración del software. Cada una de las utilidades consiste en una línea de comandos con múltiples opciones. Se puede acceder a la documentación de cada comando utilizando el parámetro \textit{- -help}. En la tabla \ref{t-ovs-commands} se listan los comandos de estas herramientas que fueron más utilizados a lo largo del desarrollo.

\begin{table}[th]
	\caption{Comandos de ovs frecuentemente utilizados}
	\label{t-ovs-commands}
	\resizebox{\textwidth}{!}{
		\begin{tabular}{|c|l|}
			\hline
			\rowcolor[HTML]{C0C0C0} 
			\textbf{Comando}                                                                & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}\textbf{Descripción}}          \\ \hline
			\textit{ovs-vsctl show}                                                         & \begin{tabular}[c]{@{}l@{}}Muestra una breve descripción de la             \\  base de datos\end{tabular}                          \\ \hline
			\rowcolor[HTML]{C0C0C0} 
			\textit{ovs-vsctl add-br}                                                       & Crea un vSwitch en  la base de datos                                        \\ \hline
			\textit{ovs-vsctl add-port}                                                     & \begin{tabular}[c]{@{}l@{}}Conecta una interfaz (virtual o física) a       \\ un vSwitch\end{tabular}                       \\ \hline
			\rowcolor[HTML]{C0C0C0} 
			\textit{ovs-ofctl show}                                                         & \begin{tabular}[c]{@{}l@{}}Muestra la configuración Openflow de un         \\ vSwitch\end{tabular}                            \\ \hline
			\textit{ovs-ofctl snoop}                                                        & \begin{tabular}[c]{@{}l@{}}Imprime los mensajes Openflow que llegan al      \\  \textit{switch}\end{tabular}                         \\ \hline
			\rowcolor[HTML]{C0C0C0} 
			\multicolumn{1}{|l|}{\cellcolor[HTML]{C0C0C0}\textit{ovs-vsctl set-controller}} & \begin{tabular}[c]{@{}l@{}}Permite asociar un controlador SDN al            \\ dispositivo\end{tabular}                           \\ \hline
			\rowcolor[HTML]{FFFFFF} 
			\textit{ovs-ofctl  dump-flows}                                                  & \begin{tabular}[c]{@{}l@{}}Muestra los flujos de un vSwitch que están en la \\  base de datos\end{tabular}              \\ \hline
			\rowcolor[HTML]{C0C0C0} 
			\textit{ovs-dpctl dump-flows}                                                   & \begin{tabular}[c]{@{}l@{}}Muestra información exacta sobre los matches en \\  la tabla del kernel (caché)\end{tabular} \\ \hline
		\end{tabular}
	}
\end{table}

En \parencite{mininetovs} se puede acceder a una presentación a cargo del uno de los desarrolladores Mininet en la que explica su funcionamiento con ejemplos. Se distingue en la diapositiva 7 una implementación interesante de como emular una topología sobre el kernel de Linux, a través de las herramientas mencionadas con anterioridad.

\subsection{Desarrollo de una topología}

Entonces, sobre estos principios se construye Mininet, facilitando la creación de topologías de red en entornos SDN, ya sea por medio de una línea de comandos o de la API de \textit{Python}. A través de esta última interfaz permite la programación en tres diferentes capas de abstracción, de alto, medio y bajo nivel. La API a bajo nivel está compuesta por las clases básicas como \textit{Switch} y Link, los cuales pueden instanciarse individualmente, lo cual complica un poco la implementación. La API a medio nivel se abstrae de los objetos anteriores, instanciando un único objeto Mininet, sobre el cual se agregan \textit{hosts} y enlaces y se brindan las directivas a la red con comandos como \textit{start()} y \textit{stop()}. Por último, la API a alto nivel crea \textit{templates} de topologías, con la habilidad de ser reusables y parametrizadas.

Como prueba de la herramienta, a lo largo del proyecto se desarrollaron diferentes topologías, con distintas características. A continuación, en el código \ref{lst:simpletest} se presenta un sencillo ejemplo del desarrollo de un esquema de red en \textit{Python}. Donde la creación de la topología se lleva a cabo íntegramente en método simpleTest, utilizando la API de medio nivel definida anteriormente. 

% cSpell:disable
\begin{lstlisting}[caption={Creación de una topología sencilla en Mininet}, captionpos=b, label={lst:simpletest}, language=Python]
#!/usr/bin/python                                                                            

import os                                                                            
from mininet.node import RemoteController                                                                                     
from mininet.topo import Topo
from mininet.net import Mininet
from mininet.util import dumpNodeConnections
from mininet.log import setLogLevel, info
from mininet.cli import CLI
from mininet.link import TCLink,Intf

def simpleTest():
    "Creacion de topologia con dos nodos OVS y 4 hosts"
	net = Mininet(link=TCLink)
	
    h1 = net.addHost( 'h1', ip ='10.10.0.1/24', mac='00:0c:29:60:dd:01')
    h2 = net.addHost( 'h2', ip ='10.10.0.2/24', mac='00:0c:29:60:dd:02')
    h3 = net.addHost( 'h3', ip ='10.10.0.3/24', mac='00:0c:29:60:dd:03')
    h4 = net.addHost( 'h4', ip ='10.10.0.4/24', mac='00:0c:29:60:dd:04')

    #Agrego switch un nodo que esta ejecuatndo un switch openflow
    s1 = net.addSwitch( 's1', protocols='OpenFlow13' )
    s2 = net.addSwitch( 's2', protocols='OpenFlow13' )

    #Creacion de enlaces entre los nodos
    net.addLink( s1, s2 )  
    net.addLink( s1, h1 )  
    net.addLink( s1, h2 )
    net.addLink( s2, h3 )
    net.addLink( s2, h4 )

    #Agrego el controlador en el puerto 6633 utilizado para la comunicacion con los dispositivos
    net.addController( 'c0', controller=RemoteController, ip='172.16.0.167', port=6633 ) 

	net.start()

    print "Comprobando la conectividad de la red"
    net.pingAll()

    #Inicio la linea de comandos
    CLI(net)
    net.stop()

if __name__ == '__main__':
    setLogLevel('info')
    simpleTest()
\end{lstlisting}
% cSpell:enable
A través del objeto Mininet se configura inicialmente la topología y a partir de las funciones a continuación se agregan elementos a la misma:
\begin{itemize}
	\item \textbf{addHost(nombre, params)}: permite agregar un nodo con características definidas en los parámetros de la función. Entre las opciones a configurar se encuentran la dirección IP, MAC, ruta por defecto, entre otras.
	\item \textbf{addSwitch(nombre, params)}: añade un \textit{switch}, al igual que la función anterior también permite la configuración a través de parámetros, entre los cuales se encuentra el tipo de \textit{switch} a utilizar y versión del protocolo OpenFlow.
	\item \textbf{addLink(nodo1, nodo2, params)} crea un enlace virtual entre dos nodos permitiendo la configuración del ancho de banda o el tipo de enlace que se utiliza.
	\item \textbf{addController(nombre, params):} conecta a la red un controlador remoto en este caso, con las características pasadas como parámetros. 
	\item \textbf{start()}: inicializa el controlador y los \textit{switches}.
	\item \textbf{pingAll()}: utiliza el comando \texttt{ping} en todos los \textit{hosts} para comprobar la conectividad y devuelve el porcentaje de pérdidas.
	\item \textbf{CLI(net)}: inicializa una línea de comandos para interactuar con la topología.
	\item \textbf{stop()}: detiene el controlador y los \textit{switches}, elimina la topología habilitando el entorno para la creación de una nueva.
\end{itemize}
Luego, para iniciar la red se corre simplemente este código en Python con permisos de administrador (\texttt{root}) y se accede a la línea de comando de Mininet como se puede ver en la figura \ref{fig:climn}. En la figura \ref{fig:topmn} se puede ver el esquema de red creado y su comunicación con el controlador.
\begin{figure}[th]
	\centering 
	\resizebox{0.75\textwidth}{!}{\includegraphics{Figures/mn-cli.png}}
	\caption[Creación de una topología en Mininet]{Creación de una topología en Mininet.}
	\label{fig:climn}
\end{figure}
\begin{figure}[th]
	\centering 
	\resizebox{0.75\textwidth}{!}{\includegraphics{Figures/topomn.png}}
	\caption[Topología sencilla creada a través de Mininet]{Topología sencilla creada con el código \ref{lst:simpletest} a través de Mininet.}
	\label{fig:topmn}
\end{figure}


%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\section{Análisis de los controladores SDN} \label{AnalisisControladoresSDN}
El foco de esta sección es realizar una comparación entre los controladores \textit{OpenDaylight} (ODL) y \textit{Open Network Operating System} (ONOS) que según \parencite{book_SDN_a_c_a} son los controladores comercialmente viables sobresalientes. Prestaremos principal atención a las funcionalidades más innovadoras que brindan ambos controladores tales como protocolos \textit{SouthBound}, arquitecturas internas, escalabilidad, interfaz \textit{NorthBound} y soluciones para los prestadores de servicio.

\subsection{Protocolos \textit{SouthBound}}

Como protocolos de comunicación entre los dispositivos de red y el controlador, ONOS brinda soporte a OpenFlow, NETCONF, REST, SNMP, TL1 \parencite{onosSouthboundProtocols}. Mientras que ODL brinda soporte a un mayor número como por ejemplo BGP, Netconf, OpenFlow, OVSDB. La lista completa de protocolos soportados por ODL se ve en la parte inferior de la figura \ref{fig:ODLCarbon} \parencite{odlSouthboundProtocols}. Para soportar esta numerosa cantidad de protocolos \textit{Southbound}, ODL implementa una capa de abstracción de servicio la cual permite a las aplicaciones dentro del controlador abstraerse del protocolo utilizado.  


\begin{figure}[th]
	\centering 
	\resizebox{1\textwidth}{!}{\includegraphics{Figures/CarbonDiagrams_final.png}}%
	\caption[Arquitectura de OpenDaylight Carbon]{Arquitectura de OpenDaylight Carbon. \parencite{odlarch}}
	\label{fig:ODLCarbon}
\end{figure}

\subsubsection*{Capa de abstracción de servicios basada en modelos}

Con la capa de abstracción de servicios basada en modelos, o por sus siglas en inglés MD-SAL, ODL brinda a los desarrolladores de aplicaciones APIs independientes al protocolo empleado. Además, para facilitar la comunicación inter-aplicación define servicios y librerías estandarizadas por modelos YANG.    

\subsection{Soluciones para los proveedores de servicio}

Muchos proveedores de servicios han participado en la definición del protocolo OpenFlow, sin embargo, cambiar su ambiente actual a OpenFlow no es algo que se pueda lograr en el corto plazo. Es por eso que empresas, como Deutsche Telekom o AT\&T, brindan soluciones SDN utilizando NETCONF, que es un protocolo con más trayectoria y despliegue. 

Si bien el protocolo base de ONOS es OpenFlow, es un controlador diseñado específicamente para los proveedores de servicios. La diferencia está en la arquitectura del controlador. ONOS posee un núcleo distribuido lo que implica la posibilidad de soportar enormes cantidades de dispositivos de red. En la próxima sección se detalla más sobre esto.

\subsection{Escalabilidad, rendimiento y alta disponibilidad}

Con el nivel de crecimiento del consumo de tráfico en las redes y la demanda de ancho de banda en alza, es necesario para los proveedores de servicio que la escalabilidad y el rendimiento de sus redes alcance niveles mucho mayores a los de hoy en día. Debido a esto, la solución de SDN debe poseer tres atributos claves, \textit{Escalabilidad, Rendimiento y Alta Disponibilidad}.

\begin{itemize}
	\item \textbf{Escalabilidad:} la nube, el streaming de video sumado al \textit{Internet de las cosas} demanda a los controladores SDN la habilidad de manejar grandes cantidades de tráfico, dispositivos de red y \textit{hosts}.
	\item \textbf{Rendimiento:} la tecnología debe ser capaz de adaptarse dinámicamente a las fluctuaciones en la carga de tráfico y congestión de la red. Si el controlador se sobrecarga agravaría el estado de una red congestionada.    
	\item \textbf{Alta Disponibilidad:} al centralizarse todo el plano de control sobre el controlador, este juega un papel crítico, generándose la necesidad de disponibilidad ininterrumpida del controlador.
\end{itemize}

Ambos controladores proponen ideas distintas para alcanzar estas metas. Por un lado, las primeras versiones de ODL era más una prueba de concepto por lo cual no presentaba gran robustez en su escalabilidad, rendimiento y disponibilidad. Para alcanzar la alta disponibilidad, en los subsiguientes \textit{releases} de OpenDaylight sí implemento una solución basada en \textit{Akka}. Consiste en una serie de herramientas que permite simplificar la creación de aplicaciones que se ejecutarán en ambientes distribuidos. 

A su vez, para mejorar la performance, ODL reparte las funcionalidades del controlador de manera distribuida para balancear la carga a lo largo del \textit{cluster}. Esta división de funcionalidades es denominada \textit{shards}. La desventaja de esta última solución es si un \textit{host} del cluster se cae, se requiere un tiempo para que el sistema se recupere. En la figura \ref{fig:ODLCluster} se ilustra un ejemplo de un cluster formado con ODL.       

\begin{figure}[th]
	\centering 
	\resizebox{1\textwidth}{!}{\includegraphics{Figures/odlCluster.png}}%
	\caption[ODL Clustering]{Cluster formado por ODL.}
	\label{fig:ODLCluster}
\end{figure}

Por otro lado, ONOS es un controlador que fue concebido y construido para ser escalable y de alto rendimiento. Por ende, su diseño es distribuido, permitiéndole controlar ambientes enormemente escalables. En la figura \ref{fig:ONOSCluster} se representa como el núcleo de ONOS es distribuido entre los \textit{hosts} del cluster y la existencia de una interfaz \textit{northbound} basada en \textit{intents}, la cual explicaremos en la siguiente sección.   
 
\begin{figure}[th]
	\centering 
	\resizebox{1\textwidth}{!}{\includegraphics{Figures/onosCluster.png}}%
	\caption[ONOS Clustering]{Cluster formado por ONOS.}
	\label{fig:ONOSCluster}
\end{figure}

\subsection{Aplicaciones basadas en Intents}
\label{subs:intents}

En un principio, los controladores SDN se construyen con el solo propósito de crear APIs en Java o REST para permitir a las aplicaciones programar con OpenFlow a los dispositivos de red. Esto, sin duda, agregaba demasiada complejidad a las aplicaciones. Actualmente, ambos controladores ODL y ONOS implementan esta interfaz basada en \textit{intents}.

Por ejemplo, si una aplicación deseaba establecer algún tipo de comunicación entre el \textit{host} A y B debía programar cada uno de los \textit{switches} involucrados en el camino entre ambos \textit{hosts}. Sin embargo, con la API \textit{northbound} basada en \textit{intents} la aplicación simplemente expresa su deseo de conectar el \textit{host} A y B, y el controlador se encarga de programar las reglas en todos los dispositivos en la trayectoria. En la sección \ref{sec:creacion_rutas_multicast} se desarrolla más el concepto de \textit{intents}.

\subsection{Elección del controlador ONOS}

Presentado el análisis de las dos implementaciones de un controlador SDN \textit{open source} más relevantes, \textit{OpenDaylight} y \textit{Open Network Operating System}, en esta sección justificaremos nuestra elección de ONOS como controlador SDN de este proyecto.

En primer lugar, la documentación de ONOS es más clara y organizada, lo cual mejora la curva de aprendizaje de las distintas herramientas y procedimientos para instalar, ejecutar e interaccionar con el controlador. A su vez, se brindan diversos tutoriales y ejemplos de distintas aplicaciones, lo cual facilitó el desarrollo e inserción de una aplicación personalizada en el núcleo del controlador.   

Segundo, cómo se aludió anteriormente, ONOS es un controlador diseñado para ofrecer escalabilidad, rendimiento y alta disponibilidad. Su arquitectura de núcleo distribuido, como muestra la figura \ref{fig:ONOSArq}, y la posibilidad de soportar un gran número de dispositivos de red simultáneamente es una cualidad sobresaliente de ONOS.

\begin{figure}[th]
	\centering 
	\resizebox{1\textwidth}{!}{\includegraphics{Figures/onos-architecture.png}}%
	\caption[Arquitectura de ONOS]{Arquitectura de ONOS.}
	\label{fig:ONOSArq}
\end{figure}

Tercero, hoy en día las redes de los proveedores de servicio son complejas y multicapas, incluyendo capas ópticas. ONOS ha logrado brindar soporte a las redes ópticas según lo demuestra el caso de uso descripto en \parencite{onosPacketOptical}.

Finalmente, se distingue un crecimiento de un $10\%$ en la utilización de ONOS. Esto se observa en los reportes anuales de 2016 y 2017 de \textit{SDx Central} sobre el avance de las tecnologías relacionadas a SDN (figuras \ref{fig:2016Report} y \ref{fig:2017Report}). Sin embargo, ODL sigue siendo el dominante por un amplio margen \parencite{SDXCentralReport}.  

\begin{figure}[th]
	\centering
		\includegraphics[width=1\linewidth]{Figures/snxcentral2016.png}
		\caption{Comparación de la utilización de los controladores SDN según el reporte de 2016 de SDx Central.}
		\label{fig:2016Report}
\end{figure}
\begin{figure}[th]
	\centering
		\includegraphics[width=1\linewidth]{Figures/snxcentral2017.png}
		\caption{Comparación de la utilización de los controladores SDN según el reporte de 2017 de SDx Central.}
		\label{fig:2017Report}
\end{figure}