/***********************************************************************/
/* This file contains information proprietary to Cortina Systems, Inc. */
/* (Cortina). Any use or disclosure, in whole or in part, of this      */
/* information to any unauthorized party, for any purposes other than  */
/* that for which it is provided is expressly prohibited except as     */
/* authorized by Cortina in writing. Cortina reserves its rights to    */
/* pursue both civil and criminal penalties for copying or disclosure  */
/* of this material without authorization. Cortina Systems (R),        */
/* Cortina (TM) and the Cortina Systems Earth Logo are the trademarks  */
/* or registered trademarks of Cortina Systems, Inc. and its           */
/* subsidiaries in the U.S. and other countries. Any other product     */
/* and company names are the trademarks of their respective owners.    */
/* Copyright (C) 2006-2013 Cortina Systems, Inc. All rights reserved.  */
/***********************************************************************/
/*
 * ten_hl_config_misc_t41.c
 *
 * API's for misc T41 high level configuration functions
 *
 * $Id: ten_hl_config_misc_t41.c,v 1.15 2013/11/26 15:47:09 jccarlis Exp $
 *
 */
 
#include "tenabo40.h"

/****************************************************************/
/* $rtn_hdr_start  HIGH LEVEL CONFIG OF PP40G PBERT             */
/* CATEGORY   : API                                             */
/* ACCESS     : Public                                          */
/* BLOCK      : HIGH LEVEL CONFIG                               */
/* CHIP       : Tenabo                                          */
cs_status ten_hl_config_40g_pbert_t41(cs_uint16           module_id,
                                      ten_xcon_len_mode_t mode, 
                                      cs_uint16           min_len,
                                      cs_uint16           max_len,
                                      cs_uint8            typelength_lsb,
                                      cs_uint8            typelength_msb,
                                      cs_uint16           ifg,
                                      ten_xcon_da_type_t  da_type)
/* INPUTS     : o Module Id                                     */
/*              o Length Mode                                   */
/*              o Minimum Octets Per Unit                       */
/*              o Maximum Octets Per Unit                       */
/*              o Type/Length Least Significant Byte            */
/*              o Type/Length Most Significant Byte             */
/*              o Inter Frame Gap                               */
/*              o Detination Address Type                       */
/* OUTPUTS    : ----                                            */
/* RETURNS    : CS_OK or CS_ERROR                               */
/* DESCRIPTION:                                                 */
/* Write PP40G PBERT configuration registers.                   */
/*                                                              */
/* The [mode] parameter specifies the unit length mode as:      */
/*   0 = XCON_UNIT_LEN_RANDOM                                   */
/*       Random unit length bound by MINLEN/MAXLEN/RNDMASK.     */
/*       The random unit length is generated by using 15 bits   */
/*       of a PRBS23. The 15 bits are masked by RNDMASK and then*/
/*       subjected to a MINLEN/MAXLEN filter.                   */
/*   1 = XCON_UNIT_LEN_LINEAR                                   */
/*       Incrementing unit length MINLEN -> MAXLEN              */
/*       (wrap-around to MINLEN)                                */
/*                                                              */
/* The [min_len] parameter selects the unit minimum length value*/
/* (number of octets per unit). For MODE[traffic]=OS unit       */
/* minimum length must satisfy 'minlen % 4 = 0'                 */
/* When ULEN[mode]=LIN, set MINLEN=MAXLEN for fixed length units*/
/*   0 - 0x7FFF                                                 */
/*                                                              */
/* The [max_len] paramter selects the unit maximum length value */
/* (number of octets per unit). For MODE[traffic]=OS, unit      */
/* maximum length must satisfy 'maxlen % 4 = 0'                 */ 
/* When ULEN[mode]=LIN, set MAXLEN=MINLEN for fixed length units*/
/*   0 - 0x7FFF                                                 */
/*                                                              */
/* The [typelength_lsb] parameter is specified as:              */
/*   0 - 0xFF                                                   */
/*                                                              */
/* The [typelength_msb] parameter is specified as:              */
/*   0 - 0xFF                                                   */
/*                                                              */
/* The [ifg] parameter is the inter frame gap specified as:     */
/*   0 = Line rate                                              */
/*   1 - 0x3FFF columns of inter frame gap                      */
/*                                                              */
/* The [da_type)] parameter is specified as:                    */
/*   0 = XCON_DA_UCAST                                          */
/*   1 = XCON_DA_MCAST                                          */
/*   2 = XCON_DA_BCAST                                          */
/*                                                              */
/* $rtn_hdr_end                                                 */
/****************************************************************/
{
  cs_uint16 dev_id = TEN_MOD_ID_TO_DEV_ID(module_id);
  cs_status rtn = CS_OK;


  if (!ten_dev_is_t41(dev_id)) {
    CS_HNDL_ERROR(module_id, ETEN_MOD_INVALID_USER_ARG, ": T41-only feature.");
    return (CS_ERROR);
  }

  /* Enable PBERT */
  rtn |= ten_pp40g_pbert_enable_t41(module_id, CS_ENABLE);

  /* Clear PBERT soft reset */
  rtn |= ten_pp40g_pbert40g_tx_control_sreset_t41(module_id, CS_RESET_DEASSERT);

  rtn |= ten_pp40g_set_pbert_protocol_t41(module_id, da_type);

                                               
  rtn |= ten_pp40g_pbert_set_frame_length_t41(module_id,
                                              mode, 
                                              0x7FFF, /* random mask value */
                                              min_len,
                                              max_len,
                                              typelength_lsb,
                                              typelength_msb);

  rtn |= ten_pp40g_pbert_control_traffic_t41(module_id, 0); /* Continuous traffic */

  rtn |= ten_pp40g_pbert_control_ifg_t41(module_id,ifg); 

  rtn |= ten_pp40g_pbert_select_fixed_pattern_t41(module_id, XCON_FIXED_PATTERN_01, 0x00, 0x11);
  rtn |= ten_pp40g_pbert_select_fixed_pattern_t41(module_id, XCON_FIXED_PATTERN_23, 0x22, 0x33);

  return (rtn);
}

/****************************************************************/
/* $rtn_hdr_start  CONFIG REMOVE SOFT RESETS                    */
/* CATEGORY   : API                                             */
/* ACCESS     : Public                                          */
/* BLOCK      : HIGH LEVEL                                      */
/* CHIP       : Tenabo                                          */
cs_status ten_hl_config_passive_monitor(cs_uint16 mod_line,
                                        cs_uint8  slice_line,
                                        cs_uint16 mod_client,
                                        cs_uint8  slice_client,
                                        cs_uint16 type)
/* INPUTS     : o Module Id Line                                */
/*              o Slice Line                                    */
/*              o Module Id Client                              */
/*              o Slice Client                                  */
/*              o Traffic Type                                  */
/* OUTPUTS    : ----                                            */
/* RETURNS    : CS_OK or CS_ERROR                               */
/* DESCRIPTION:                                                 */
/* Provision both sides of a wire configuration for passive     */
/* monitoring.                                                  */
/*                                                              */
/* The [slice_line, slice_client] parameters are specified as:  */
/* The [slice_client] parameter is specified as:                */
/*   0x00 = TEN_SLICE0                                          */
/*   0x01 = TEN_SLICE1                                          */
/*   0x02 = TEN_SLICE2                                          */
/*   0x03 = TEN_SLICE3                                          */
/*   0xFF = TEN_SLICE_ALL.                                      */
/*                                                              */
/* The [type] parameter is specified as:                        */
/*   TEN_TRAFFIC_TYPE_10GFC                = 13                 */
/*   TEN_TRAFFIC_TYPE_8GFC                 = 14                 */
/*   TEN_TRAFFIC_TYPE_4GFC                 = 15                 */
/*   TEN_TRAFFIC_TYPE_2GFC                 = 16                 */
/*   TEN_TRAFFIC_TYPE_1GFC                 = 17                 */
/*   TEN_TRAFFIC_TYPE_10GE                 = 20                 */
/*   TEN_TRAFFIC_TYPE_10GFC_TC_G709        = 57                 */
/*                                                              */
/* $rtn_hdr_end                                                 */
/****************************************************************/
{
  cs_status rtn = CS_OK;
  cs_char8 *func = "ten_hl_config_passive_monitor";  
  ten_dev_cb_t *pdevcb;

  CS_PRINT("%s()\n", func);
  CS_PRINT("    line  %s, %s\n", ten_module_strings[mod_line&1], ten_slice_strings[slice_line]);
  CS_PRINT("    client  %s, %s\n", ten_module_strings[mod_client&1], ten_slice_strings[slice_client]);
  CS_PRINT("    type =%s\n", ten_hl_config_traffic_types_strings[type]);
  
  switch (type) {
    case TEN_TRAFFIC_TYPE_8GFC:
    case TEN_TRAFFIC_TYPE_4GFC:
    case TEN_TRAFFIC_TYPE_2GFC:
    case TEN_TRAFFIC_TYPE_1GFC:
      rtn |= ten_hl_pp10g_config(mod_line,   slice_line,   TEN_PP10G_RX_8FC, TEN_PP10G_TX_DISABLE);
      rtn |= ten_hl_pp10g_config(mod_client, slice_client, TEN_PP10G_RX_8FC, TEN_PP10G_TX_DISABLE);
      break;

    case TEN_TRAFFIC_TYPE_10GFC:
    case TEN_TRAFFIC_TYPE_10GFC_TC:
    case TEN_TRAFFIC_TYPE_10GFC_TC_G709: /* Bug 31054 */
      rtn |= ten_hl_pp10g_config(mod_line,   slice_line,   TEN_PP10G_RX_FC, TEN_PP10G_TX_DISABLE);
      rtn |= ten_hl_pp10g_config(mod_client, slice_client, TEN_PP10G_RX_FC, TEN_PP10G_TX_DISABLE);
      break;
      
    case TEN_TRAFFIC_TYPE_10GE:
      if (ten_hsif_is_xaui_active(mod_client, slice_client)) {
        rtn |= ten_hl_pp10g_config(mod_line, slice_line, TEN_PP10G_RX_ETH_4, TEN_PP10G_TX_ETH_4);
        rtn |= ten_hl_pp10g_config(mod_client, slice_client, TEN_PP10G_RX_XAUI_ETH_4_RA, TEN_PP10G_TX_XAUI_ETH_4);
      }
      else {
        rtn |= ten_hl_pp10g_config(mod_line, slice_line, TEN_PP10G_RX_ETH_0, TEN_PP10G_TX_ETH_0); 
        rtn |= ten_hl_pp10g_config(mod_client, slice_client, TEN_PP10G_RX_ETH_0, TEN_PP10G_TX_ETH_0);
      }
      break;
      
    default: 
      CS_PRINT("Passive monitoring not enabled for this traffic type.\n");
      break;
  }

  /* Bugzilla #32732,  Enable BER counter in wire configurations */
  pdevcb = TEN_DEV_ID_TO_DEVCB_PTR(TEN_MOD_ID_TO_DEV_ID(mod_line));
  CS_PRINT("sysclk = %d\n", pdevcb->sysclock/1000000);
  
  /* Bug #42185: 8GFC wire mode passes but has bus errors */
  if ((type != TEN_TRAFFIC_TYPE_8GFC) && (type != TEN_TRAFFIC_TYPE_4GFC) &&
      (type != TEN_TRAFFIC_TYPE_2GFC) && (type != TEN_TRAFFIC_TYPE_1GFC)) {
    /* Bugzilla #35750: fix Bus errors during Release 5.7 Regression testing */
    if (!(ten_pp10g_get_misc_reset(mod_line, slice_line))) {
      ten_pp10g_set_pcs_rx_ber_timer(mod_line, slice_line, (pdevcb->sysclock/1000000)*125);
    }
    if (!(ten_pp10g_get_misc_reset(mod_client, slice_client))) {
      ten_pp10g_set_pcs_rx_ber_timer(mod_client, slice_client, (pdevcb->sysclock/1000000)*125);
    }
  }
  
  return (rtn);
}

