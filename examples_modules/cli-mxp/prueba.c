
/* 
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.11-0

  Combined SIL module
  module cli-mxp
  revision 2018-06-24
  namespace http://fulgor.com/ns/cli-mxp

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_not.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"
#include "cli-mxp.h"

/* module static variables */
static ncx_module_t *cli_mxp_mod;
static obj_template_t *mux_config_obj;
static obj_template_t *mux_state_obj;
static obj_template_t *mux_state_misc_obj;
static obj_template_t *mux_state_TX_RX_alarms_obj;
static obj_template_t *mux_state_power_obj;
static obj_template_t *mux_state_dsp_obj;
static obj_template_t *mux_state_edfa_obj;
static obj_template_t *mux_optical_line_status_obj;
static obj_template_t *mux_notify_activate_obj;
static obj_template_t *mux_notify_deactivate_obj;
static obj_template_t *mux_apply_config_obj;
static obj_template_t *mux_settings_obj;
static obj_template_t *mux_notify_obj;
static val_value_t *mux_config_val;

/* put your static variables here */

/********************************************************************
* FUNCTION y_cli_mxp_init_static_vars
* 
* initialize module static variables
* 
********************************************************************/
static void y_cli_mxp_init_static_vars (void)
{
  cli_mxp_mod = NULL;
  mux_config_obj = NULL;
  mux_state_obj = NULL;
  mux_state_misc_obj = NULL;
  mux_state_TX_RX_alarms_obj = NULL;
  mux_state_power_obj = NULL;
  mux_state_dsp_obj = NULL;
  mux_state_edfa_obj = NULL;
  mux_optical_line_status_obj = NULL;
  mux_notify_activate_obj = NULL;
  mux_notify_deactivate_obj = NULL;
  mux_apply_config_obj = NULL;
  mux_settings_obj = NULL;
  mux_notify_obj = NULL;
  mux_config_val = NULL;

  /* init your static variables here */

} /* y_cli_mxp_init_static_vars */


/********************************************************************
* FUNCTION cli_mxp_mux_config_configuracion_edit
* 
* Edit database object callback
* Path: /mux-config/configuracion
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_configuracion_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_configuracion_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_configuracion_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_tipo_trafico_edit
* 
* Edit database object callback
* Path: /mux-config/tipo_trafico
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_tipo_trafico_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_tipo_trafico_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_tipo_trafico_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_tipo_fec_linea_edit
* 
* Edit database object callback
* Path: /mux-config/tipo_fec_linea
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_tipo_fec_linea_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_tipo_fec_linea_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_tipo_fec_linea_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_tipo_fec_cliente_edit
* 
* Edit database object callback
* Path: /mux-config/tipo_fec_cliente
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_tipo_fec_cliente_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_tipo_fec_cliente_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_tipo_fec_cliente_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_canal_edit
* 
* Edit database object callback
* Path: /mux-config/canal
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_canal_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_canal_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_canal_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_potencia_edit
* 
* Edit database object callback
* Path: /mux-config/potencia
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_potencia_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_potencia_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_potencia_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_cd_compensacion_edit
* 
* Edit database object callback
* Path: /mux-config/cd_compensacion
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_cd_compensacion_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_cd_compensacion_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_cd_compensacion_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_edfa_output_power_config_edit
* 
* Edit database object callback
* Path: /mux-config/edfa_output_power_config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_edfa_output_power_config_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_edfa_output_power_config_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_edfa_output_power_config_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_time_notify_config_edit
* 
* Edit database object callback
* Path: /mux-config/time_notify_config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_time_notify_config_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_time_notify_config_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_time_notify_config_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_deviceneighbors_edit
* 
* Edit database object callback
* Path: /mux-config/deviceneighbors
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_deviceneighbors_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_deviceneighbors_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_deviceneighbors_edit */


/********************************************************************
* FUNCTION cli_mxp_mux_config_edit
* 
* Edit database object callback
* Path: /mux-config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_config_edit (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  agt_cbtyp_t cbtyp,
  op_editop_t editop,
  val_value_t *newval,
  val_value_t *curval)
{
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_config_edit callback for %s phase",
      agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
  case AGT_CB_VALIDATE:
    /* description-stmt validation here */
    break;
  case AGT_CB_APPLY:
    /* database manipulation done here */
    break;
  case AGT_CB_COMMIT:
    /* device instrumentation done here */
    switch (editop) {
    case OP_EDITOP_LOAD:
      break;
    case OP_EDITOP_MERGE:
      break;
    case OP_EDITOP_REPLACE:
      break;
    case OP_EDITOP_CREATE:
      break;
    case OP_EDITOP_DELETE:
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res == NO_ERR) {
      res = agt_check_cache(&mux_config_val, newval, curval, editop);
    }
    
    break;
  case AGT_CB_ROLLBACK:
    /* undo device instrumentation here */
    break;
  default:
    res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_CONTENT,
      res,
      NULL,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* cli_mxp_mux_config_edit */

/********************************************************************
* FUNCTION cli_mxp_mux_state_fpga_temperature_state_get
* 
* Get database object callback
* Path: /mux-state/fpga_temperature_state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_fpga_temperature_state_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int64 fpga_temperature_state;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_fpga_temperature_state_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the fpga_temperature_state var here, change zero */
  fpga_temperature_state = (const xmlChar *)"0.0";
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    fpga_temperature_state);

  return res;

} /* cli_mxp_mux_state_fpga_temperature_state_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_board_humidity_state_get
* 
* Get database object callback
* Path: /mux-state/board_humidity_state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_board_humidity_state_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int16 board_humidity_state;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_board_humidity_state_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the board_humidity_state var here, change zero */
  board_humidity_state = 0;
  VAL_INT16(dstval) = board_humidity_state;

  return res;

} /* cli_mxp_mux_state_board_humidity_state_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_edfa_output_power_state_get
* 
* Get database object callback
* Path: /mux-state/edfa_output_power_state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_edfa_output_power_state_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int64 edfa_output_power_state;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_edfa_output_power_state_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the edfa_output_power_state var here, change zero */
  edfa_output_power_state = (const xmlChar *)"0.0";
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    edfa_output_power_state);

  return res;

} /* cli_mxp_mux_state_edfa_output_power_state_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_xfp_tx_power_get
* 
* Get database object callback
* Path: /mux-state/xfp_tx_power
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_xfp_tx_power_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int64 xfp_tx_power;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_xfp_tx_power_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the xfp_tx_power var here, change zero */
  xfp_tx_power = (const xmlChar *)"0.0";
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    xfp_tx_power);

  return res;

} /* cli_mxp_mux_state_xfp_tx_power_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_xfp_rx_power_get
* 
* Get database object callback
* Path: /mux-state/xfp_rx_power
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_xfp_rx_power_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int64 xfp_rx_power;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_xfp_rx_power_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the xfp_rx_power var here, change zero */
  xfp_rx_power = (const xmlChar *)"0.0";
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    xfp_rx_power);

  return res;

} /* cli_mxp_mux_state_xfp_rx_power_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_device_manufacturer_get
* 
* Get database object callback
* Path: /mux-state/device_manufacturer
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_device_manufacturer_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *device_manufacturer;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_device_manufacturer_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the device_manufacturer var here, change EMPTY_STRING */
  device_manufacturer = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    device_manufacturer);

  return res;

} /* cli_mxp_mux_state_device_manufacturer_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_device_swVersion_get
* 
* Get database object callback
* Path: /mux-state/device_swVersion
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_device_swVersion_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *device_swVersion;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_device_swVersion_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the device_swVersion var here, change EMPTY_STRING */
  device_swVersion = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    device_swVersion);

  return res;

} /* cli_mxp_mux_state_device_swVersion_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_device_hwVersion_get
* 
* Get database object callback
* Path: /mux-state/device_hwVersion
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_device_hwVersion_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *device_hwVersion;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_device_hwVersion_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the device_hwVersion var here, change EMPTY_STRING */
  device_hwVersion = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    device_hwVersion);

  return res;

} /* cli_mxp_mux_state_device_hwVersion_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_device_boardId_get
* 
* Get database object callback
* Path: /mux-state/device_boardId
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_device_boardId_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *device_boardId;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_device_boardId_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the device_boardId var here, change EMPTY_STRING */
  device_boardId = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    device_boardId);

  return res;

} /* cli_mxp_mux_state_device_boardId_get */


/********************************************************************
* FUNCTION cli_mxp_mux_state_mro
* 
* Make read-only top-level node
* Path: /mux-state
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
  cli_mxp_mux_state_mro (void)
{
  val_value_t *parentval = NULL, *childval = NULL;
  status_t res = NO_ERR;


  /* add /mux-state */
  res = agt_add_top_container(mux_state_obj, &parentval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /mux-state/fpga_temperature_state */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_fpga_temperature_state,
    cli_mxp_mux_state_fpga_temperature_state_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/board_humidity_state */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_board_humidity_state,
    cli_mxp_mux_state_board_humidity_state_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/edfa_output_power_state */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_edfa_output_power_state,
    cli_mxp_mux_state_edfa_output_power_state_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/xfp_tx_power */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_xfp_tx_power,
    cli_mxp_mux_state_xfp_tx_power_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/xfp_rx_power */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_xfp_rx_power,
    cli_mxp_mux_state_xfp_rx_power_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/device_manufacturer */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_device_manufacturer,
    cli_mxp_mux_state_device_manufacturer_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/device_swVersion */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_device_swVersion,
    cli_mxp_mux_state_device_swVersion_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/device_hwVersion */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_device_hwVersion,
    cli_mxp_mux_state_device_hwVersion_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state/device_boardId */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_device_boardId,
    cli_mxp_mux_state_device_boardId_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* cli_mxp_mux_state_mro */

/********************************************************************
* FUNCTION cli_mxp_mux_state_misc_temp_around_get
* 
* Get database object callback
* Path: /mux-state-misc/temp_around
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_misc_temp_around_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *temp_around;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_misc_temp_around_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the temp_around var here, change EMPTY_STRING */
  temp_around = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    temp_around);

  return res;

} /* cli_mxp_mux_state_misc_temp_around_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_misc_temp_case_get
* 
* Get database object callback
* Path: /mux-state-misc/temp_case
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_misc_temp_case_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *temp_case;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_misc_temp_case_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the temp_case var here, change EMPTY_STRING */
  temp_case = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    temp_case);

  return res;

} /* cli_mxp_mux_state_misc_temp_case_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_misc_temp_tx_laser_get
* 
* Get database object callback
* Path: /mux-state-misc/temp_tx_laser
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_misc_temp_tx_laser_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *temp_tx_laser;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_misc_temp_tx_laser_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the temp_tx_laser var here, change EMPTY_STRING */
  temp_tx_laser = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    temp_tx_laser);

  return res;

} /* cli_mxp_mux_state_misc_temp_tx_laser_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_misc_temp_rx_laser_get
* 
* Get database object callback
* Path: /mux-state-misc/temp_rx_laser
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_misc_temp_rx_laser_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *temp_rx_laser;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_misc_temp_rx_laser_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the temp_rx_laser var here, change EMPTY_STRING */
  temp_rx_laser = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    temp_rx_laser);

  return res;

} /* cli_mxp_mux_state_misc_temp_rx_laser_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_misc_loss_get
* 
* Get database object callback
* Path: /mux-state-misc/loss
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_misc_loss_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *loss;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_misc_loss_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the loss var here, change EMPTY_STRING */
  loss = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    loss);

  return res;

} /* cli_mxp_mux_state_misc_loss_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_misc_interrupt_get
* 
* Get database object callback
* Path: /mux-state-misc/interrupt
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_misc_interrupt_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *interrupt;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_misc_interrupt_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the interrupt var here, change EMPTY_STRING */
  interrupt = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    interrupt);

  return res;

} /* cli_mxp_mux_state_misc_interrupt_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_misc_tx_laser_itu_band_get
* 
* Get database object callback
* Path: /mux-state-misc/tx_laser_itu_band
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_misc_tx_laser_itu_band_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *tx_laser_itu_band;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_misc_tx_laser_itu_band_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the tx_laser_itu_band var here, change EMPTY_STRING */
  tx_laser_itu_band = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    tx_laser_itu_band);

  return res;

} /* cli_mxp_mux_state_misc_tx_laser_itu_band_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_misc_tx_laser_itu_channel_get
* 
* Get database object callback
* Path: /mux-state-misc/tx_laser_itu_channel
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_misc_tx_laser_itu_channel_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *tx_laser_itu_channel;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_misc_tx_laser_itu_channel_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the tx_laser_itu_channel var here, change EMPTY_STRING */
  tx_laser_itu_channel = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    tx_laser_itu_channel);

  return res;

} /* cli_mxp_mux_state_misc_tx_laser_itu_channel_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_misc_rx_laser_itu_band_get
* 
* Get database object callback
* Path: /mux-state-misc/rx_laser_itu_band
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_misc_rx_laser_itu_band_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *rx_laser_itu_band;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_misc_rx_laser_itu_band_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the rx_laser_itu_band var here, change EMPTY_STRING */
  rx_laser_itu_band = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    rx_laser_itu_band);

  return res;

} /* cli_mxp_mux_state_misc_rx_laser_itu_band_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_misc_rx_laser_itu_channel_get
* 
* Get database object callback
* Path: /mux-state-misc/rx_laser_itu_channel
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_misc_rx_laser_itu_channel_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *rx_laser_itu_channel;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_misc_rx_laser_itu_channel_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the rx_laser_itu_channel var here, change EMPTY_STRING */
  rx_laser_itu_channel = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    rx_laser_itu_channel);

  return res;

} /* cli_mxp_mux_state_misc_rx_laser_itu_channel_get */


/********************************************************************
* FUNCTION cli_mxp_mux_state_misc_mro
* 
* Make read-only top-level node
* Path: /mux-state-misc
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
  cli_mxp_mux_state_misc_mro (void)
{
  val_value_t *parentval = NULL, *childval = NULL;
  status_t res = NO_ERR;


  /* add /mux-state-misc */
  res = agt_add_top_container(mux_state_misc_obj, &parentval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /mux-state-misc/temp_around */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_temp_around,
    cli_mxp_mux_state_misc_temp_around_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-misc/temp_case */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_temp_case,
    cli_mxp_mux_state_misc_temp_case_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-misc/temp_tx_laser */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_temp_tx_laser,
    cli_mxp_mux_state_misc_temp_tx_laser_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-misc/temp_rx_laser */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_temp_rx_laser,
    cli_mxp_mux_state_misc_temp_rx_laser_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-misc/loss */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_loss,
    cli_mxp_mux_state_misc_loss_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-misc/interrupt */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_interrupt,
    cli_mxp_mux_state_misc_interrupt_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-misc/tx_laser_itu_band */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_tx_laser_itu_band,
    cli_mxp_mux_state_misc_tx_laser_itu_band_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-misc/tx_laser_itu_channel */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_tx_laser_itu_channel,
    cli_mxp_mux_state_misc_tx_laser_itu_channel_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-misc/rx_laser_itu_band */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_rx_laser_itu_band,
    cli_mxp_mux_state_misc_rx_laser_itu_band_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-misc/rx_laser_itu_channel */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_rx_laser_itu_channel,
    cli_mxp_mux_state_misc_rx_laser_itu_channel_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* cli_mxp_mux_state_misc_mro */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_EOL_ALM_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/EOL_ALM
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_EOL_ALM_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *EOL_ALM;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_EOL_ALM_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the EOL_ALM var here, change EMPTY_STRING */
  EOL_ALM = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    EOL_ALM);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_EOL_ALM_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_MOD_TEMP_ALM_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/MOD_TEMP_ALM
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_MOD_TEMP_ALM_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *MOD_TEMP_ALM;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_MOD_TEMP_ALM_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MOD_TEMP_ALM var here, change EMPTY_STRING */
  MOD_TEMP_ALM = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    MOD_TEMP_ALM);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_MOD_TEMP_ALM_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_TX_OOA_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/TX_OOA
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_TX_OOA_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *TX_OOA;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_TX_OOA_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TX_OOA var here, change EMPTY_STRING */
  TX_OOA = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    TX_OOA);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_TX_OOA_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_TX_LOF_ALM_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/TX_LOF_ALM
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_TX_LOF_ALM_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *TX_LOF_ALM;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_TX_LOF_ALM_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TX_LOF_ALM var here, change EMPTY_STRING */
  TX_LOF_ALM = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    TX_LOF_ALM);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_TX_LOF_ALM_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_TX_DSC_ERR_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/TX_DSC_ERR
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_TX_DSC_ERR_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *TX_DSC_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_TX_DSC_ERR_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TX_DSC_ERR var here, change EMPTY_STRING */
  TX_DSC_ERR = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    TX_DSC_ERR);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_TX_DSC_ERR_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_LS_WAV_ALM_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/LS_WAV_ALM
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_LS_WAV_ALM_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *LS_WAV_ALM;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_LS_WAV_ALM_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LS_WAV_ALM var here, change EMPTY_STRING */
  LS_WAV_ALM = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    LS_WAV_ALM);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_LS_WAV_ALM_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_TX_ALM_INT_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/TX_ALM_INT
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_TX_ALM_INT_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *TX_ALM_INT;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_TX_ALM_INT_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TX_ALM_INT var here, change EMPTY_STRING */
  TX_ALM_INT = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    TX_ALM_INT);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_TX_ALM_INT_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_LS_BIAS_ALM_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/LS_BIAS_ALM
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_LS_BIAS_ALM_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *LS_BIAS_ALM;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_LS_BIAS_ALM_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LS_BIAS_ALM var here, change EMPTY_STRING */
  LS_BIAS_ALM = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    LS_BIAS_ALM);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_LS_BIAS_ALM_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_LS_TEMP_ALM_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/LS_TEMP_ALM
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_LS_TEMP_ALM_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *LS_TEMP_ALM;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_LS_TEMP_ALM_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LS_TEMP_ALM var here, change EMPTY_STRING */
  LS_TEMP_ALM = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    LS_TEMP_ALM);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_LS_TEMP_ALM_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_TX_LOCK_ERR_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/TX_LOCK_ERR
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_TX_LOCK_ERR_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *TX_LOCK_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_TX_LOCK_ERR_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TX_LOCK_ERR var here, change EMPTY_STRING */
  TX_LOCK_ERR = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    TX_LOCK_ERR);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_TX_LOCK_ERR_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_LS_POW_ALM_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/LS_POW_ALM
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_LS_POW_ALM_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *LS_POW_ALM;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_LS_POW_ALM_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LS_POW_ALM var here, change EMPTY_STRING */
  LS_POW_ALM = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    LS_POW_ALM);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_LS_POW_ALM_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_MOD_BIAS_ALM_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/MOD_BIAS_ALM
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_MOD_BIAS_ALM_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *MOD_BIAS_ALM;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_MOD_BIAS_ALM_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MOD_BIAS_ALM var here, change EMPTY_STRING */
  MOD_BIAS_ALM = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    MOD_BIAS_ALM);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_MOD_BIAS_ALM_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_LATCHED_TXFIFO_ERR_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/LATCHED_TXFIFO_ERR
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_LATCHED_TXFIFO_ERR_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *LATCHED_TXFIFO_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_LATCHED_TXFIFO_ERR_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LATCHED_TXFIFO_ERR var here, change EMPTY_STRING */
  LATCHED_TXFIFO_ERR = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    LATCHED_TXFIFO_ERR);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_LATCHED_TXFIFO_ERR_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_RXALM_INT_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/RXALM_INT
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_RXALM_INT_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *RXALM_INT;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_RXALM_INT_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the RXALM_INT var here, change EMPTY_STRING */
  RXALM_INT = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    RXALM_INT);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_RXALM_INT_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_RXPOW_ALM_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/RXPOW_ALM
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_RXPOW_ALM_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *RXPOW_ALM;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_RXPOW_ALM_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the RXPOW_ALM var here, change EMPTY_STRING */
  RXPOW_ALM = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    RXPOW_ALM);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_RXPOW_ALM_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_RX_LOS_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/RX_LOS
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_RX_LOS_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *RX_LOS;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_RX_LOS_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the RX_LOS var here, change EMPTY_STRING */
  RX_LOS = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    RX_LOS);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_RX_LOS_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_RX_LOCK_ERR_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/RX_LOCK_ERR
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_RX_LOCK_ERR_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *RX_LOCK_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_RX_LOCK_ERR_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the RX_LOCK_ERR var here, change EMPTY_STRING */
  RX_LOCK_ERR = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    RX_LOCK_ERR);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_RX_LOCK_ERR_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_RXS_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/RXS
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_RXS_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *RXS;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_RXS_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the RXS var here, change EMPTY_STRING */
  RXS = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    RXS);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_RXS_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_PRBS_ERR_DET_get
* 
* Get database object callback
* Path: /mux-state-TX-RX-alarms/PRBS_ERR_DET
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_TX_RX_alarms_PRBS_ERR_DET_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *PRBS_ERR_DET;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_TX_RX_alarms_PRBS_ERR_DET_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PRBS_ERR_DET var here, change EMPTY_STRING */
  PRBS_ERR_DET = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    PRBS_ERR_DET);

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_PRBS_ERR_DET_get */


/********************************************************************
* FUNCTION cli_mxp_mux_state_TX_RX_alarms_mro
* 
* Make read-only top-level node
* Path: /mux-state-TX-RX-alarms
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
  cli_mxp_mux_state_TX_RX_alarms_mro (void)
{
  val_value_t *parentval = NULL, *childval = NULL;
  status_t res = NO_ERR;


  /* add /mux-state-TX-RX-alarms */
  res = agt_add_top_container(mux_state_TX_RX_alarms_obj, &parentval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/EOL_ALM */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_EOL_ALM,
    cli_mxp_mux_state_TX_RX_alarms_EOL_ALM_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/MOD_TEMP_ALM */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_MOD_TEMP_ALM,
    cli_mxp_mux_state_TX_RX_alarms_MOD_TEMP_ALM_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/TX_OOA */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_TX_OOA,
    cli_mxp_mux_state_TX_RX_alarms_TX_OOA_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/TX_LOF_ALM */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_TX_LOF_ALM,
    cli_mxp_mux_state_TX_RX_alarms_TX_LOF_ALM_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/TX_DSC_ERR */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_TX_DSC_ERR,
    cli_mxp_mux_state_TX_RX_alarms_TX_DSC_ERR_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/LS_WAV_ALM */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_LS_WAV_ALM,
    cli_mxp_mux_state_TX_RX_alarms_LS_WAV_ALM_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/TX_ALM_INT */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_TX_ALM_INT,
    cli_mxp_mux_state_TX_RX_alarms_TX_ALM_INT_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/LS_BIAS_ALM */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_LS_BIAS_ALM,
    cli_mxp_mux_state_TX_RX_alarms_LS_BIAS_ALM_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/LS_TEMP_ALM */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_LS_TEMP_ALM,
    cli_mxp_mux_state_TX_RX_alarms_LS_TEMP_ALM_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/TX_LOCK_ERR */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_TX_LOCK_ERR,
    cli_mxp_mux_state_TX_RX_alarms_TX_LOCK_ERR_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/LS_POW_ALM */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_LS_POW_ALM,
    cli_mxp_mux_state_TX_RX_alarms_LS_POW_ALM_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/MOD_BIAS_ALM */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_MOD_BIAS_ALM,
    cli_mxp_mux_state_TX_RX_alarms_MOD_BIAS_ALM_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/LATCHED_TXFIFO_ERR */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_LATCHED_TXFIFO_ERR,
    cli_mxp_mux_state_TX_RX_alarms_LATCHED_TXFIFO_ERR_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/RXALM_INT */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_RXALM_INT,
    cli_mxp_mux_state_TX_RX_alarms_RXALM_INT_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/RXPOW_ALM */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_RXPOW_ALM,
    cli_mxp_mux_state_TX_RX_alarms_RXPOW_ALM_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/RX_LOS */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_RX_LOS,
    cli_mxp_mux_state_TX_RX_alarms_RX_LOS_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/RX_LOCK_ERR */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_RX_LOCK_ERR,
    cli_mxp_mux_state_TX_RX_alarms_RX_LOCK_ERR_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/RXS */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_RXS,
    cli_mxp_mux_state_TX_RX_alarms_RXS_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-TX-RX-alarms/PRBS_ERR_DET */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_PRBS_ERR_DET,
    cli_mxp_mux_state_TX_RX_alarms_PRBS_ERR_DET_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* cli_mxp_mux_state_TX_RX_alarms_mro */

/********************************************************************
* FUNCTION cli_mxp_mux_state_power_PSUMMARY_get
* 
* Get database object callback
* Path: /mux-state-power/PSUMMARY
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_power_PSUMMARY_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *PSUMMARY;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_power_PSUMMARY_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PSUMMARY var here, change EMPTY_STRING */
  PSUMMARY = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    PSUMMARY);

  return res;

} /* cli_mxp_mux_state_power_PSUMMARY_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_power_P5VANALOG_get
* 
* Get database object callback
* Path: /mux-state-power/P5VANALOG
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_power_P5VANALOG_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *P5VANALOG;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_power_P5VANALOG_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the P5VANALOG var here, change EMPTY_STRING */
  P5VANALOG = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    P5VANALOG);

  return res;

} /* cli_mxp_mux_state_power_P5VANALOG_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_power_N5V2ANALOG_get
* 
* Get database object callback
* Path: /mux-state-power/N5V2ANALOG
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_power_N5V2ANALOG_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *N5V2ANALOG;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_power_N5V2ANALOG_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the N5V2ANALOG var here, change EMPTY_STRING */
  N5V2ANALOG = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    N5V2ANALOG);

  return res;

} /* cli_mxp_mux_state_power_N5V2ANALOG_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_power_P3P3VANALOG_get
* 
* Get database object callback
* Path: /mux-state-power/P3P3VANALOG
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_power_P3P3VANALOG_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *P3P3VANALOG;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_power_P3P3VANALOG_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the P3P3VANALOG var here, change EMPTY_STRING */
  P3P3VANALOG = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    P3P3VANALOG);

  return res;

} /* cli_mxp_mux_state_power_P3P3VANALOG_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_power_P3P3VDIGITAL_get
* 
* Get database object callback
* Path: /mux-state-power/P3P3VDIGITAL
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_power_P3P3VDIGITAL_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *P3P3VDIGITAL;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_power_P3P3VDIGITAL_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the P3P3VDIGITAL var here, change EMPTY_STRING */
  P3P3VDIGITAL = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    P3P3VDIGITAL);

  return res;

} /* cli_mxp_mux_state_power_P3P3VDIGITAL_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_power_LVDIGITAL_get
* 
* Get database object callback
* Path: /mux-state-power/LVDIGITAL
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_power_LVDIGITAL_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *LVDIGITAL;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_power_LVDIGITAL_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LVDIGITAL var here, change EMPTY_STRING */
  LVDIGITAL = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    LVDIGITAL);

  return res;

} /* cli_mxp_mux_state_power_LVDIGITAL_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_power_N5P2VDIGITAL_get
* 
* Get database object callback
* Path: /mux-state-power/N5P2VDIGITAL
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_power_N5P2VDIGITAL_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *N5P2VDIGITAL;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_power_N5P2VDIGITAL_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the N5P2VDIGITAL var here, change EMPTY_STRING */
  N5P2VDIGITAL = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    N5P2VDIGITAL);

  return res;

} /* cli_mxp_mux_state_power_N5P2VDIGITAL_get */


/********************************************************************
* FUNCTION cli_mxp_mux_state_power_mro
* 
* Make read-only top-level node
* Path: /mux-state-power
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
  cli_mxp_mux_state_power_mro (void)
{
  val_value_t *parentval = NULL, *childval = NULL;
  status_t res = NO_ERR;


  /* add /mux-state-power */
  res = agt_add_top_container(mux_state_power_obj, &parentval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /mux-state-power/PSUMMARY */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_PSUMMARY,
    cli_mxp_mux_state_power_PSUMMARY_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-power/P5VANALOG */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_P5VANALOG,
    cli_mxp_mux_state_power_P5VANALOG_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-power/N5V2ANALOG */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_N5V2ANALOG,
    cli_mxp_mux_state_power_N5V2ANALOG_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-power/P3P3VANALOG */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_P3P3VANALOG,
    cli_mxp_mux_state_power_P3P3VANALOG_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-power/P3P3VDIGITAL */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_P3P3VDIGITAL,
    cli_mxp_mux_state_power_P3P3VDIGITAL_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-power/LVDIGITAL */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_LVDIGITAL,
    cli_mxp_mux_state_power_LVDIGITAL_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-power/N5P2VDIGITAL */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_N5P2VDIGITAL,
    cli_mxp_mux_state_power_N5P2VDIGITAL_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* cli_mxp_mux_state_power_mro */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_DSP_running_get
* 
* Get database object callback
* Path: /mux-state-dsp/DSP_running
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_DSP_running_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *DSP_running;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_DSP_running_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the DSP_running var here, change EMPTY_STRING */
  DSP_running = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    DSP_running);

  return res;

} /* cli_mxp_mux_state_dsp_DSP_running_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_CONVERGED_get
* 
* Get database object callback
* Path: /mux-state-dsp/CONVERGED
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_CONVERGED_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *CONVERGED;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_CONVERGED_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the CONVERGED var here, change EMPTY_STRING */
  CONVERGED = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    CONVERGED);

  return res;

} /* cli_mxp_mux_state_dsp_CONVERGED_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_MSE_below_threshold_get
* 
* Get database object callback
* Path: /mux-state-dsp/MSE_below_threshold
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_MSE_below_threshold_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *MSE_below_threshold;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_MSE_below_threshold_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MSE_below_threshold var here, change EMPTY_STRING */
  MSE_below_threshold = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    MSE_below_threshold);

  return res;

} /* cli_mxp_mux_state_dsp_MSE_below_threshold_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_BCD_Enabled_get
* 
* Get database object callback
* Path: /mux-state-dsp/BCD_Enabled
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_BCD_Enabled_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *BCD_Enabled;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_BCD_Enabled_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the BCD_Enabled var here, change EMPTY_STRING */
  BCD_Enabled = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    BCD_Enabled);

  return res;

} /* cli_mxp_mux_state_dsp_BCD_Enabled_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_Coarse_Carrier_Lock_get
* 
* Get database object callback
* Path: /mux-state-dsp/Coarse_Carrier_Lock
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_Coarse_Carrier_Lock_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *Coarse_Carrier_Lock;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_Coarse_Carrier_Lock_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the Coarse_Carrier_Lock var here, change EMPTY_STRING */
  Coarse_Carrier_Lock = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    Coarse_Carrier_Lock);

  return res;

} /* cli_mxp_mux_state_dsp_Coarse_Carrier_Lock_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_Collision_get
* 
* Get database object callback
* Path: /mux-state-dsp/Collision
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_Collision_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *Collision;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_Collision_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the Collision var here, change EMPTY_STRING */
  Collision = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    Collision);

  return res;

} /* cli_mxp_mux_state_dsp_Collision_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_DSP_Initialized_get
* 
* Get database object callback
* Path: /mux-state-dsp/DSP_Initialized
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_DSP_Initialized_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *DSP_Initialized;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_DSP_Initialized_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the DSP_Initialized var here, change EMPTY_STRING */
  DSP_Initialized = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    DSP_Initialized);

  return res;

} /* cli_mxp_mux_state_dsp_DSP_Initialized_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_Presence_of_light_get
* 
* Get database object callback
* Path: /mux-state-dsp/Presence_of_light
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_Presence_of_light_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *Presence_of_light;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_Presence_of_light_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the Presence_of_light var here, change EMPTY_STRING */
  Presence_of_light = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    Presence_of_light);

  return res;

} /* cli_mxp_mux_state_dsp_Presence_of_light_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_Local_Oscillator_running_get
* 
* Get database object callback
* Path: /mux-state-dsp/Local_Oscillator_running
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_Local_Oscillator_running_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *Local_Oscillator_running;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_Local_Oscillator_running_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the Local_Oscillator_running var here, change EMPTY_STRING */
  Local_Oscillator_running = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    Local_Oscillator_running);

  return res;

} /* cli_mxp_mux_state_dsp_Local_Oscillator_running_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_Transmit_Laser_running_get
* 
* Get database object callback
* Path: /mux-state-dsp/Transmit_Laser_running
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_Transmit_Laser_running_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *Transmit_Laser_running;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_Transmit_Laser_running_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the Transmit_Laser_running var here, change EMPTY_STRING */
  Transmit_Laser_running = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    Transmit_Laser_running);

  return res;

} /* cli_mxp_mux_state_dsp_Transmit_Laser_running_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_MSE_XI_get
* 
* Get database object callback
* Path: /mux-state-dsp/MSE_XI
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_MSE_XI_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *MSE_XI;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_MSE_XI_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MSE_XI var here, change EMPTY_STRING */
  MSE_XI = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    MSE_XI);

  return res;

} /* cli_mxp_mux_state_dsp_MSE_XI_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_MSE_XQ_get
* 
* Get database object callback
* Path: /mux-state-dsp/MSE_XQ
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_MSE_XQ_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *MSE_XQ;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_MSE_XQ_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MSE_XQ var here, change EMPTY_STRING */
  MSE_XQ = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    MSE_XQ);

  return res;

} /* cli_mxp_mux_state_dsp_MSE_XQ_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_MSE_YI_get
* 
* Get database object callback
* Path: /mux-state-dsp/MSE_YI
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_MSE_YI_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *MSE_YI;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_MSE_YI_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MSE_YI var here, change EMPTY_STRING */
  MSE_YI = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    MSE_YI);

  return res;

} /* cli_mxp_mux_state_dsp_MSE_YI_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_MSE_YQ_get
* 
* Get database object callback
* Path: /mux-state-dsp/MSE_YQ
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_MSE_YQ_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *MSE_YQ;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_MSE_YQ_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MSE_YQ var here, change EMPTY_STRING */
  MSE_YQ = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    MSE_YQ);

  return res;

} /* cli_mxp_mux_state_dsp_MSE_YQ_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_BER_Estimate_get
* 
* Get database object callback
* Path: /mux-state-dsp/BER_Estimate
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_BER_Estimate_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *BER_Estimate;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_BER_Estimate_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the BER_Estimate var here, change EMPTY_STRING */
  BER_Estimate = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    BER_Estimate);

  return res;

} /* cli_mxp_mux_state_dsp_BER_Estimate_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_Min_Bulk_CD_Compensation_ps_nm_get
* 
* Get database object callback
* Path: /mux-state-dsp/Min_Bulk_CD_Compensation_ps_nm
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_Min_Bulk_CD_Compensation_ps_nm_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *Min_Bulk_CD_Compensation_ps_nm;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_Min_Bulk_CD_Compensation_ps_nm_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the Min_Bulk_CD_Compensation_ps_nm var here, change EMPTY_STRING */
  Min_Bulk_CD_Compensation_ps_nm = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    Min_Bulk_CD_Compensation_ps_nm);

  return res;

} /* cli_mxp_mux_state_dsp_Min_Bulk_CD_Compensation_ps_nm_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_Max_Bulk_CD_Compensation_ps_nm_get
* 
* Get database object callback
* Path: /mux-state-dsp/Max_Bulk_CD_Compensation_ps_nm
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_Max_Bulk_CD_Compensation_ps_nm_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *Max_Bulk_CD_Compensation_ps_nm;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_Max_Bulk_CD_Compensation_ps_nm_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the Max_Bulk_CD_Compensation_ps_nm var here, change EMPTY_STRING */
  Max_Bulk_CD_Compensation_ps_nm = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    Max_Bulk_CD_Compensation_ps_nm);

  return res;

} /* cli_mxp_mux_state_dsp_Max_Bulk_CD_Compensation_ps_nm_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_Step_Size_ps_nm_get
* 
* Get database object callback
* Path: /mux-state-dsp/Step_Size_ps_nm
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_Step_Size_ps_nm_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *Step_Size_ps_nm;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_Step_Size_ps_nm_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the Step_Size_ps_nm var here, change EMPTY_STRING */
  Step_Size_ps_nm = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    Step_Size_ps_nm);

  return res;

} /* cli_mxp_mux_state_dsp_Step_Size_ps_nm_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_CD_Compensation_ps_nm_get
* 
* Get database object callback
* Path: /mux-state-dsp/CD_Compensation_ps_nm
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_dsp_CD_Compensation_ps_nm_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *CD_Compensation_ps_nm;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_dsp_CD_Compensation_ps_nm_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the CD_Compensation_ps_nm var here, change EMPTY_STRING */
  CD_Compensation_ps_nm = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    CD_Compensation_ps_nm);

  return res;

} /* cli_mxp_mux_state_dsp_CD_Compensation_ps_nm_get */


/********************************************************************
* FUNCTION cli_mxp_mux_state_dsp_mro
* 
* Make read-only top-level node
* Path: /mux-state-dsp
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
  cli_mxp_mux_state_dsp_mro (void)
{
  val_value_t *parentval = NULL, *childval = NULL;
  status_t res = NO_ERR;


  /* add /mux-state-dsp */
  res = agt_add_top_container(mux_state_dsp_obj, &parentval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /mux-state-dsp/DSP_running */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_DSP_running,
    cli_mxp_mux_state_dsp_DSP_running_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/CONVERGED */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_CONVERGED,
    cli_mxp_mux_state_dsp_CONVERGED_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/MSE_below_threshold */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_MSE_below_threshold,
    cli_mxp_mux_state_dsp_MSE_below_threshold_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/BCD_Enabled */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_BCD_Enabled,
    cli_mxp_mux_state_dsp_BCD_Enabled_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/Coarse_Carrier_Lock */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_Coarse_Carrier_Lock,
    cli_mxp_mux_state_dsp_Coarse_Carrier_Lock_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/Collision */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_Collision,
    cli_mxp_mux_state_dsp_Collision_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/DSP_Initialized */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_DSP_Initialized,
    cli_mxp_mux_state_dsp_DSP_Initialized_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/Presence_of_light */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_Presence_of_light,
    cli_mxp_mux_state_dsp_Presence_of_light_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/Local_Oscillator_running */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_Local_Oscillator_running,
    cli_mxp_mux_state_dsp_Local_Oscillator_running_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/Transmit_Laser_running */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_Transmit_Laser_running,
    cli_mxp_mux_state_dsp_Transmit_Laser_running_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/MSE_XI */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_MSE_XI,
    cli_mxp_mux_state_dsp_MSE_XI_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/MSE_XQ */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_MSE_XQ,
    cli_mxp_mux_state_dsp_MSE_XQ_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/MSE_YI */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_MSE_YI,
    cli_mxp_mux_state_dsp_MSE_YI_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/MSE_YQ */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_MSE_YQ,
    cli_mxp_mux_state_dsp_MSE_YQ_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/BER_Estimate */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_BER_Estimate,
    cli_mxp_mux_state_dsp_BER_Estimate_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/Min_Bulk_CD_Compensation_ps_nm */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_Min_Bulk_CD_Compensation_ps_nm,
    cli_mxp_mux_state_dsp_Min_Bulk_CD_Compensation_ps_nm_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/Max_Bulk_CD_Compensation_ps_nm */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_Max_Bulk_CD_Compensation_ps_nm,
    cli_mxp_mux_state_dsp_Max_Bulk_CD_Compensation_ps_nm_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/Step_Size_ps_nm */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_Step_Size_ps_nm,
    cli_mxp_mux_state_dsp_Step_Size_ps_nm_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-dsp/CD_Compensation_ps_nm */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_CD_Compensation_ps_nm,
    cli_mxp_mux_state_dsp_CD_Compensation_ps_nm_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* cli_mxp_mux_state_dsp_mro */

/********************************************************************
* FUNCTION cli_mxp_mux_state_edfa_POUT_get
* 
* Get database object callback
* Path: /mux-state-edfa/POUT
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_edfa_POUT_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *POUT;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_edfa_POUT_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the POUT var here, change EMPTY_STRING */
  POUT = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    POUT);

  return res;

} /* cli_mxp_mux_state_edfa_POUT_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_edfa_PIN_get
* 
* Get database object callback
* Path: /mux-state-edfa/PIN
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_edfa_PIN_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *PIN;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_edfa_PIN_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PIN var here, change EMPTY_STRING */
  PIN = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    PIN);

  return res;

} /* cli_mxp_mux_state_edfa_PIN_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_edfa_Temp_get
* 
* Get database object callback
* Path: /mux-state-edfa/Temp
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_edfa_Temp_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *Temp;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_edfa_Temp_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the Temp var here, change EMPTY_STRING */
  Temp = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    Temp);

  return res;

} /* cli_mxp_mux_state_edfa_Temp_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_edfa_LOS_get
* 
* Get database object callback
* Path: /mux-state-edfa/LOS
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_edfa_LOS_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *LOS;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_edfa_LOS_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LOS var here, change EMPTY_STRING */
  LOS = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    LOS);

  return res;

} /* cli_mxp_mux_state_edfa_LOS_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_edfa_LOP_get
* 
* Get database object callback
* Path: /mux-state-edfa/LOP
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_edfa_LOP_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *LOP;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_edfa_LOP_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LOP var here, change EMPTY_STRING */
  LOP = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    LOP);

  return res;

} /* cli_mxp_mux_state_edfa_LOP_get */

/********************************************************************
* FUNCTION cli_mxp_mux_state_edfa_Amp_stat_get
* 
* Get database object callback
* Path: /mux-state-edfa/Amp_stat
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_state_edfa_Amp_stat_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *Amp_stat;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_state_edfa_Amp_stat_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the Amp_stat var here, change EMPTY_STRING */
  Amp_stat = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    Amp_stat);

  return res;

} /* cli_mxp_mux_state_edfa_Amp_stat_get */


/********************************************************************
* FUNCTION cli_mxp_mux_state_edfa_mro
* 
* Make read-only top-level node
* Path: /mux-state-edfa
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
  cli_mxp_mux_state_edfa_mro (void)
{
  val_value_t *parentval = NULL, *childval = NULL;
  status_t res = NO_ERR;


  /* add /mux-state-edfa */
  res = agt_add_top_container(mux_state_edfa_obj, &parentval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /mux-state-edfa/POUT */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_POUT,
    cli_mxp_mux_state_edfa_POUT_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-edfa/PIN */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_PIN,
    cli_mxp_mux_state_edfa_PIN_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-edfa/Temp */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_Temp,
    cli_mxp_mux_state_edfa_Temp_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-edfa/LOS */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_LOS,
    cli_mxp_mux_state_edfa_LOS_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-edfa/LOP */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_LOP,
    cli_mxp_mux_state_edfa_LOP_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /mux-state-edfa/Amp_stat */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_Amp_stat,
    cli_mxp_mux_state_edfa_Amp_stat_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* cli_mxp_mux_state_edfa_mro */

/********************************************************************
* FUNCTION cli_mxp_mux_optical_line_status_brctl_showstp_br0_get
* 
* Get database object callback
* Path: /mux-optical-line-status/brctl_showstp_br0
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t cli_mxp_mux_optical_line_status_brctl_showstp_br0_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *brctl_showstp_br0;

  if (LOGDEBUG) {
    log_debug("\nEnter cli_mxp_mux_optical_line_status_brctl_showstp_br0_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the brctl_showstp_br0 var here, change EMPTY_STRING */
  brctl_showstp_br0 = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    brctl_showstp_br0);

  return res;

} /* cli_mxp_mux_optical_line_status_brctl_showstp_br0_get */


/********************************************************************
* FUNCTION cli_mxp_mux_optical_line_status_mro
* 
* Make read-only top-level node
* Path: /mux-optical-line-status
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
  cli_mxp_mux_optical_line_status_mro (void)
{
  val_value_t *parentval = NULL, *childval = NULL;
  status_t res = NO_ERR;


  /* add /mux-optical-line-status */
  res = agt_add_top_container(mux_optical_line_status_obj, &parentval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /mux-optical-line-status/brctl_showstp_br0 */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_cli_mxp_N_brctl_showstp_br0,
    cli_mxp_mux_optical_line_status_brctl_showstp_br0_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* cli_mxp_mux_optical_line_status_mro */


/********************************************************************
* FUNCTION y_cli_mxp_mux_notify_activate_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_notify_activate_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;


  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_cli_mxp_mux_notify_activate_validate */


/********************************************************************
* FUNCTION y_cli_mxp_mux_notify_activate_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_notify_activate_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_cli_mxp_mux_notify_activate_invoke */


/********************************************************************
* FUNCTION y_cli_mxp_mux_notify_deactivate_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_notify_deactivate_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;


  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_cli_mxp_mux_notify_deactivate_validate */


/********************************************************************
* FUNCTION y_cli_mxp_mux_notify_deactivate_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_notify_deactivate_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_cli_mxp_mux_notify_deactivate_invoke */


/********************************************************************
* FUNCTION y_cli_mxp_mux_apply_config_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_apply_config_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;


  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_cli_mxp_mux_apply_config_validate */


/********************************************************************
* FUNCTION y_cli_mxp_mux_apply_config_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_apply_config_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_cli_mxp_mux_apply_config_invoke */


/********************************************************************
* FUNCTION y_cli_mxp_mux_settings_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_settings_validate (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;


  if (res != NO_ERR) {
    agt_record_error(
      scb,
      &msg->mhdr,
      NCX_LAYER_OPERATION,
      res,
      methnode,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval,
      (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
      errorval);
  }
  return res;

} /* y_cli_mxp_mux_settings_validate */


/********************************************************************
* FUNCTION y_cli_mxp_mux_settings_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t y_cli_mxp_mux_settings_invoke (
  ses_cb_t *scb,
  rpc_msg_t *msg,
  xml_node_t *methnode)
{
  status_t res = NO_ERR;


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */
  
  return res;

} /* y_cli_mxp_mux_settings_invoke */


/********************************************************************
* FUNCTION y_cli_mxp_mux_notify_send
* 
* Send a y_cli_mxp_mux_notify notification
* Called by your code when notification event occurs
* 
********************************************************************/
void y_cli_mxp_mux_notify_send (
  const xmlChar *INFO)
{
  agt_not_msg_t *notif;
  val_value_t *parmval;
  status_t res = NO_ERR;


  if (LOGDEBUG) {
    log_debug("\nGenerating <mux-notify> notification");
  }
  
  notif = agt_not_new_notification(mux_notify_obj);
  if (notif == NULL) {
    log_error("\nError: malloc failed, cannot send "
    "<mux-notify> notification");
    return;
  }
  
  /* add INFO to payload */
  parmval = agt_make_leaf(
    mux_notify_obj,
    y_cli_mxp_N_INFO,
    INFO,
    &res);
  if (parmval == NULL) {
    log_error(
      "\nError: make leaf failed (%s), cannot send "
      "<mux-notify> notification",
      get_error_string(res));
  } else {
    agt_not_add_to_payload(notif, parmval);
  }
  
  agt_not_queue_notification(notif);
  
} /* y_cli_mxp_mux_notify_send */

/********************************************************************
* FUNCTION y_cli_mxp_init
* 
* initialize the cli-mxp server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_cli_mxp_init (
  const xmlChar *modname,
  const xmlChar *revision)
{
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  y_cli_mxp_init_static_vars();

  /* change if custom handling done */
  if (xml_strcmp(modname, y_cli_mxp_M_cli_mxp)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }

  if (revision && xml_strcmp(revision, y_cli_mxp_R_cli_mxp)) {
    return ERR_NCX_WRONG_VERSION;
  }
  res = ncxmod_load_module(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_R_cli_mxp,
    &agt_profile->agt_savedevQ,
    &cli_mxp_mod);
  if (res != NO_ERR) {
    return res;
  }

  mux_config_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_config);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_state_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_state);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_state_misc_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_state_misc);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_state_TX_RX_alarms_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_state_TX_RX_alarms);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_state_power_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_state_power);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_state_dsp_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_state_dsp);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_state_edfa_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_state_edfa);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_optical_line_status_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_optical_line_status);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_notify_activate_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_notify_activate);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_notify_deactivate_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_notify_deactivate);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_apply_config_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_apply_config);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_settings_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_settings);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  mux_notify_obj = ncx_find_object(
    cli_mxp_mod,
    y_cli_mxp_N_mux_notify);
  if (cli_mxp_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_notify_activate,
    AGT_RPC_PH_VALIDATE,
    y_cli_mxp_mux_notify_activate_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_notify_activate,
    AGT_RPC_PH_INVOKE,
    y_cli_mxp_mux_notify_activate_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_notify_deactivate,
    AGT_RPC_PH_VALIDATE,
    y_cli_mxp_mux_notify_deactivate_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_notify_deactivate,
    AGT_RPC_PH_INVOKE,
    y_cli_mxp_mux_notify_deactivate_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_apply_config,
    AGT_RPC_PH_VALIDATE,
    y_cli_mxp_mux_apply_config_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_apply_config,
    AGT_RPC_PH_INVOKE,
    y_cli_mxp_mux_apply_config_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_settings,
    AGT_RPC_PH_VALIDATE,
    y_cli_mxp_mux_settings_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_settings,
    AGT_RPC_PH_INVOKE,
    y_cli_mxp_mux_settings_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/configuracion",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_configuracion_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/tipo_trafico",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_tipo_trafico_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/tipo_fec_linea",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_tipo_fec_linea_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/tipo_fec_cliente",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_tipo_fec_cliente_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/canal",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_canal_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/potencia",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_potencia_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/cd_compensacion",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_cd_compensacion_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/edfa_output_power_config",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_edfa_output_power_config_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/time_notify_config",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_time_notify_config_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/deviceneighbors",
    y_cli_mxp_R_cli_mxp,
    cli_mxp_mux_config_deviceneighbors_edit);
  if (res != NO_ERR) {
    return res;
  }

  /* put your module initialization code here */
  
  return res;
} /* y_cli_mxp_init */

/********************************************************************
* FUNCTION y_cli_mxp_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_cli_mxp_init2 (void)
{
  status_t res = NO_ERR;

  mux_config_val = agt_init_cache(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_config,
    &res);
  if (res != NO_ERR) {
    return res;
  }

  res = cli_mxp_mux_optical_line_status_mro();
  if (res != NO_ERR) {
    return res;
  }

  res = cli_mxp_mux_state_mro();
  if (res != NO_ERR) {
    return res;
  }

  res = cli_mxp_mux_state_TX_RX_alarms_mro();
  if (res != NO_ERR) {
    return res;
  }

  res = cli_mxp_mux_state_dsp_mro();
  if (res != NO_ERR) {
    return res;
  }

  res = cli_mxp_mux_state_edfa_mro();
  if (res != NO_ERR) {
    return res;
  }

  res = cli_mxp_mux_state_misc_mro();
  if (res != NO_ERR) {
    return res;
  }

  res = cli_mxp_mux_state_power_mro();
  if (res != NO_ERR) {
    return res;
  }

  /* put your init2 code here */

  return res;
} /* y_cli_mxp_init2 */

/********************************************************************
* FUNCTION y_cli_mxp_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void y_cli_mxp_cleanup (void)
{
  
  agt_rpc_unregister_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_notify_activate);
  
  agt_rpc_unregister_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_notify_deactivate);
  
  agt_rpc_unregister_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_apply_config);
  
  agt_rpc_unregister_method(
    y_cli_mxp_M_cli_mxp,
    y_cli_mxp_N_mux_settings);
  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/configuracion");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/tipo_trafico");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/tipo_fec_linea");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/tipo_fec_cliente");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/canal");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/potencia");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/cd_compensacion");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/edfa_output_power_config");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/time_notify_config");

  agt_cb_unregister_callbacks(
    y_cli_mxp_M_cli_mxp,
    (const xmlChar *)"/mux-config/deviceneighbors");

  /* put your cleanup code here */
  
} /* y_cli_mxp_cleanup */

/* END cli_mxp.c */
