/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "../../txpDSPStatusTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement txpDSPStatusTable get routines.
 * TODO:240:M: Implement txpDSPStatusTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table txpDSPStatusTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * FTNC-MIB::txpDSPStatusTable is subid 1 of txpDSP.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.43484.2.9.3.1, length: 11
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement txpDSPStatusTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param txpDSPStatusIndex_ptr
 * @param txpDSPStatusIndex_ptr_len
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
txpDSPStatusTable_indexes_set_tbl_idx(txpDSPStatusTable_mib_index *tbl_idx, char *txpDSPStatusIndex_val_ptr,  size_t txpDSPStatusIndex_val_ptr_len)
{
    DEBUGMSGTL(("verbose:txpDSPStatusTable:txpDSPStatusTable_indexes_set_tbl_idx","called\n"));

    /* txpDSPStatusIndex(1)/OCTETSTR/ASN_OCTET_STR/char(char)//L/a/w/e/R/d/h */
    tbl_idx->txpDSPStatusIndex_len = sizeof(tbl_idx->txpDSPStatusIndex)/sizeof(tbl_idx->txpDSPStatusIndex[0]); /* max length */
    /*
     * make sure there is enough space for txpDSPStatusIndex data
     */
    if ((NULL == tbl_idx->txpDSPStatusIndex) ||
        (tbl_idx->txpDSPStatusIndex_len <
         (txpDSPStatusIndex_val_ptr_len))) {
        snmp_log(LOG_ERR,"not enough space for value (txpDSPStatusIndex_val_ptr)\n");
        return MFD_ERROR;
    }
    tbl_idx->txpDSPStatusIndex_len = txpDSPStatusIndex_val_ptr_len;
    memcpy( tbl_idx->txpDSPStatusIndex, txpDSPStatusIndex_val_ptr, txpDSPStatusIndex_val_ptr_len* sizeof(txpDSPStatusIndex_val_ptr[0]) );
    

    return MFD_SUCCESS;
} /* txpDSPStatusTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
txpDSPStatusTable_indexes_set(txpDSPStatusTable_rowreq_ctx *rowreq_ctx, char *txpDSPStatusIndex_val_ptr,  size_t txpDSPStatusIndex_val_ptr_len)
{
    DEBUGMSGTL(("verbose:txpDSPStatusTable:txpDSPStatusTable_indexes_set","called\n"));

    if(MFD_SUCCESS != txpDSPStatusTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , txpDSPStatusIndex_val_ptr, txpDSPStatusIndex_val_ptr_len
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != txpDSPStatusTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* txpDSPStatusTable_indexes_set */


/*---------------------------------------------------------------------
 * FTNC-MIB::txpDSPStatusEntry.dsprunning
 * dsprunning is subid 2 of txpDSPStatusEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.43484.2.9.3.1.1.2
 * Description:
txp40G DSP running.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the dsprunning data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dsprunning_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param dsprunning_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by dsprunning.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*dsprunning_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update dsprunning_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
dsprunning_get( txpDSPStatusTable_rowreq_ctx *rowreq_ctx, char **dsprunning_val_ptr_ptr, size_t *dsprunning_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != dsprunning_val_ptr_ptr) && (NULL != *dsprunning_val_ptr_ptr));
   netsnmp_assert( NULL != dsprunning_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:txpDSPStatusTable:dsprunning_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the dsprunning data.
 * copy (* dsprunning_val_ptr_ptr ) data and (* dsprunning_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for dsprunning data
     */
    if ((NULL == (* dsprunning_val_ptr_ptr )) ||
        ((* dsprunning_val_ptr_len_ptr ) <
         (rowreq_ctx->data.dsprunning_len* sizeof(rowreq_ctx->data.dsprunning[0])))) {
        /*
         * allocate space for dsprunning data
         */
        (* dsprunning_val_ptr_ptr ) = malloc(rowreq_ctx->data.dsprunning_len* sizeof(rowreq_ctx->data.dsprunning[0]));
        if(NULL == (* dsprunning_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.dsprunning)\n");
            return MFD_ERROR;
        }
    }
    (* dsprunning_val_ptr_len_ptr ) = rowreq_ctx->data.dsprunning_len* sizeof(rowreq_ctx->data.dsprunning[0]);
    memcpy( (* dsprunning_val_ptr_ptr ), rowreq_ctx->data.dsprunning, rowreq_ctx->data.dsprunning_len* sizeof(rowreq_ctx->data.dsprunning[0]) );

    return MFD_SUCCESS;
} /* dsprunning_get */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpDSPStatusEntry.converged
 * converged is subid 3 of txpDSPStatusEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.43484.2.9.3.1.1.3
 * Description:
txp40G DSP Converged algorithms.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the converged data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param converged_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param converged_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by converged.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*converged_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update converged_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
converged_get( txpDSPStatusTable_rowreq_ctx *rowreq_ctx, char **converged_val_ptr_ptr, size_t *converged_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != converged_val_ptr_ptr) && (NULL != *converged_val_ptr_ptr));
   netsnmp_assert( NULL != converged_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:txpDSPStatusTable:converged_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the converged data.
 * copy (* converged_val_ptr_ptr ) data and (* converged_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for converged data
     */
    if ((NULL == (* converged_val_ptr_ptr )) ||
        ((* converged_val_ptr_len_ptr ) <
         (rowreq_ctx->data.converged_len* sizeof(rowreq_ctx->data.converged[0])))) {
        /*
         * allocate space for converged data
         */
        (* converged_val_ptr_ptr ) = malloc(rowreq_ctx->data.converged_len* sizeof(rowreq_ctx->data.converged[0]));
        if(NULL == (* converged_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.converged)\n");
            return MFD_ERROR;
        }
    }
    (* converged_val_ptr_len_ptr ) = rowreq_ctx->data.converged_len* sizeof(rowreq_ctx->data.converged[0]);
    memcpy( (* converged_val_ptr_ptr ), rowreq_ctx->data.converged, rowreq_ctx->data.converged_len* sizeof(rowreq_ctx->data.converged[0]) );

    return MFD_SUCCESS;
} /* converged_get */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpDSPStatusEntry.msebelowThreshold
 * msebelowThreshold is subid 4 of txpDSPStatusEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.43484.2.9.3.1.1.4
 * Description:
txp40G DSP MSE below threshold
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the msebelowThreshold data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param msebelowThreshold_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param msebelowThreshold_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by msebelowThreshold.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*msebelowThreshold_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update msebelowThreshold_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
msebelowThreshold_get( txpDSPStatusTable_rowreq_ctx *rowreq_ctx, char **msebelowThreshold_val_ptr_ptr, size_t *msebelowThreshold_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != msebelowThreshold_val_ptr_ptr) && (NULL != *msebelowThreshold_val_ptr_ptr));
   netsnmp_assert( NULL != msebelowThreshold_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:txpDSPStatusTable:msebelowThreshold_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the msebelowThreshold data.
 * copy (* msebelowThreshold_val_ptr_ptr ) data and (* msebelowThreshold_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for msebelowThreshold data
     */
    if ((NULL == (* msebelowThreshold_val_ptr_ptr )) ||
        ((* msebelowThreshold_val_ptr_len_ptr ) <
         (rowreq_ctx->data.msebelowThreshold_len* sizeof(rowreq_ctx->data.msebelowThreshold[0])))) {
        /*
         * allocate space for msebelowThreshold data
         */
        (* msebelowThreshold_val_ptr_ptr ) = malloc(rowreq_ctx->data.msebelowThreshold_len* sizeof(rowreq_ctx->data.msebelowThreshold[0]));
        if(NULL == (* msebelowThreshold_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.msebelowThreshold)\n");
            return MFD_ERROR;
        }
    }
    (* msebelowThreshold_val_ptr_len_ptr ) = rowreq_ctx->data.msebelowThreshold_len* sizeof(rowreq_ctx->data.msebelowThreshold[0]);
    memcpy( (* msebelowThreshold_val_ptr_ptr ), rowreq_ctx->data.msebelowThreshold, rowreq_ctx->data.msebelowThreshold_len* sizeof(rowreq_ctx->data.msebelowThreshold[0]) );

    return MFD_SUCCESS;
} /* msebelowThreshold_get */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpDSPStatusEntry.bcdEnable
 * bcdEnable is subid 5 of txpDSPStatusEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.43484.2.9.3.1.1.5
 * Description:
txp40G DSP enable.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the bcdEnable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param bcdEnable_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param bcdEnable_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by bcdEnable.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*bcdEnable_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update bcdEnable_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
bcdEnable_get( txpDSPStatusTable_rowreq_ctx *rowreq_ctx, char **bcdEnable_val_ptr_ptr, size_t *bcdEnable_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != bcdEnable_val_ptr_ptr) && (NULL != *bcdEnable_val_ptr_ptr));
   netsnmp_assert( NULL != bcdEnable_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:txpDSPStatusTable:bcdEnable_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the bcdEnable data.
 * copy (* bcdEnable_val_ptr_ptr ) data and (* bcdEnable_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for bcdEnable data
     */
    if ((NULL == (* bcdEnable_val_ptr_ptr )) ||
        ((* bcdEnable_val_ptr_len_ptr ) <
         (rowreq_ctx->data.bcdEnable_len* sizeof(rowreq_ctx->data.bcdEnable[0])))) {
        /*
         * allocate space for bcdEnable data
         */
        (* bcdEnable_val_ptr_ptr ) = malloc(rowreq_ctx->data.bcdEnable_len* sizeof(rowreq_ctx->data.bcdEnable[0]));
        if(NULL == (* bcdEnable_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.bcdEnable)\n");
            return MFD_ERROR;
        }
    }
    (* bcdEnable_val_ptr_len_ptr ) = rowreq_ctx->data.bcdEnable_len* sizeof(rowreq_ctx->data.bcdEnable[0]);
    memcpy( (* bcdEnable_val_ptr_ptr ), rowreq_ctx->data.bcdEnable, rowreq_ctx->data.bcdEnable_len* sizeof(rowreq_ctx->data.bcdEnable[0]) );

    return MFD_SUCCESS;
} /* bcdEnable_get */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpDSPStatusEntry.coarseCarrierLock
 * coarseCarrierLock is subid 6 of txpDSPStatusEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.43484.2.9.3.1.1.6
 * Description:
txp40G DSP Coarse Carrier Lock.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the coarseCarrierLock data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param coarseCarrierLock_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param coarseCarrierLock_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by coarseCarrierLock.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*coarseCarrierLock_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update coarseCarrierLock_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
coarseCarrierLock_get( txpDSPStatusTable_rowreq_ctx *rowreq_ctx, char **coarseCarrierLock_val_ptr_ptr, size_t *coarseCarrierLock_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != coarseCarrierLock_val_ptr_ptr) && (NULL != *coarseCarrierLock_val_ptr_ptr));
   netsnmp_assert( NULL != coarseCarrierLock_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:txpDSPStatusTable:coarseCarrierLock_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the coarseCarrierLock data.
 * copy (* coarseCarrierLock_val_ptr_ptr ) data and (* coarseCarrierLock_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for coarseCarrierLock data
     */
    if ((NULL == (* coarseCarrierLock_val_ptr_ptr )) ||
        ((* coarseCarrierLock_val_ptr_len_ptr ) <
         (rowreq_ctx->data.coarseCarrierLock_len* sizeof(rowreq_ctx->data.coarseCarrierLock[0])))) {
        /*
         * allocate space for coarseCarrierLock data
         */
        (* coarseCarrierLock_val_ptr_ptr ) = malloc(rowreq_ctx->data.coarseCarrierLock_len* sizeof(rowreq_ctx->data.coarseCarrierLock[0]));
        if(NULL == (* coarseCarrierLock_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.coarseCarrierLock)\n");
            return MFD_ERROR;
        }
    }
    (* coarseCarrierLock_val_ptr_len_ptr ) = rowreq_ctx->data.coarseCarrierLock_len* sizeof(rowreq_ctx->data.coarseCarrierLock[0]);
    memcpy( (* coarseCarrierLock_val_ptr_ptr ), rowreq_ctx->data.coarseCarrierLock, rowreq_ctx->data.coarseCarrierLock_len* sizeof(rowreq_ctx->data.coarseCarrierLock[0]) );

    return MFD_SUCCESS;
} /* coarseCarrierLock_get */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpDSPStatusEntry.collision
 * collision is subid 7 of txpDSPStatusEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.43484.2.9.3.1.1.7
 * Description:
txp40G DSP Collision.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the collision data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param collision_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param collision_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by collision.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*collision_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update collision_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
collision_get( txpDSPStatusTable_rowreq_ctx *rowreq_ctx, char **collision_val_ptr_ptr, size_t *collision_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != collision_val_ptr_ptr) && (NULL != *collision_val_ptr_ptr));
   netsnmp_assert( NULL != collision_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:txpDSPStatusTable:collision_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the collision data.
 * copy (* collision_val_ptr_ptr ) data and (* collision_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for collision data
     */
    if ((NULL == (* collision_val_ptr_ptr )) ||
        ((* collision_val_ptr_len_ptr ) <
         (rowreq_ctx->data.collision_len* sizeof(rowreq_ctx->data.collision[0])))) {
        /*
         * allocate space for collision data
         */
        (* collision_val_ptr_ptr ) = malloc(rowreq_ctx->data.collision_len* sizeof(rowreq_ctx->data.collision[0]));
        if(NULL == (* collision_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.collision)\n");
            return MFD_ERROR;
        }
    }
    (* collision_val_ptr_len_ptr ) = rowreq_ctx->data.collision_len* sizeof(rowreq_ctx->data.collision[0]);
    memcpy( (* collision_val_ptr_ptr ), rowreq_ctx->data.collision, rowreq_ctx->data.collision_len* sizeof(rowreq_ctx->data.collision[0]) );

    return MFD_SUCCESS;
} /* collision_get */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpDSPStatusEntry.dspInitialized
 * dspInitialized is subid 8 of txpDSPStatusEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.43484.2.9.3.1.1.8
 * Description:
txp40G DSP Initialized.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the dspInitialized data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dspInitialized_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param dspInitialized_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by dspInitialized.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*dspInitialized_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update dspInitialized_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
dspInitialized_get( txpDSPStatusTable_rowreq_ctx *rowreq_ctx, char **dspInitialized_val_ptr_ptr, size_t *dspInitialized_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != dspInitialized_val_ptr_ptr) && (NULL != *dspInitialized_val_ptr_ptr));
   netsnmp_assert( NULL != dspInitialized_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:txpDSPStatusTable:dspInitialized_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the dspInitialized data.
 * copy (* dspInitialized_val_ptr_ptr ) data and (* dspInitialized_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for dspInitialized data
     */
    if ((NULL == (* dspInitialized_val_ptr_ptr )) ||
        ((* dspInitialized_val_ptr_len_ptr ) <
         (rowreq_ctx->data.dspInitialized_len* sizeof(rowreq_ctx->data.dspInitialized[0])))) {
        /*
         * allocate space for dspInitialized data
         */
        (* dspInitialized_val_ptr_ptr ) = malloc(rowreq_ctx->data.dspInitialized_len* sizeof(rowreq_ctx->data.dspInitialized[0]));
        if(NULL == (* dspInitialized_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.dspInitialized)\n");
            return MFD_ERROR;
        }
    }
    (* dspInitialized_val_ptr_len_ptr ) = rowreq_ctx->data.dspInitialized_len* sizeof(rowreq_ctx->data.dspInitialized[0]);
    memcpy( (* dspInitialized_val_ptr_ptr ), rowreq_ctx->data.dspInitialized, rowreq_ctx->data.dspInitialized_len* sizeof(rowreq_ctx->data.dspInitialized[0]) );

    return MFD_SUCCESS;
} /* dspInitialized_get */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpDSPStatusEntry.presenceOfLight
 * presenceOfLight is subid 9 of txpDSPStatusEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.43484.2.9.3.1.1.9
 * Description:
txp40G DSP Presence Of Light.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the presenceOfLight data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param presenceOfLight_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param presenceOfLight_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by presenceOfLight.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*presenceOfLight_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update presenceOfLight_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
presenceOfLight_get( txpDSPStatusTable_rowreq_ctx *rowreq_ctx, char **presenceOfLight_val_ptr_ptr, size_t *presenceOfLight_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != presenceOfLight_val_ptr_ptr) && (NULL != *presenceOfLight_val_ptr_ptr));
   netsnmp_assert( NULL != presenceOfLight_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:txpDSPStatusTable:presenceOfLight_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the presenceOfLight data.
 * copy (* presenceOfLight_val_ptr_ptr ) data and (* presenceOfLight_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for presenceOfLight data
     */
    if ((NULL == (* presenceOfLight_val_ptr_ptr )) ||
        ((* presenceOfLight_val_ptr_len_ptr ) <
         (rowreq_ctx->data.presenceOfLight_len* sizeof(rowreq_ctx->data.presenceOfLight[0])))) {
        /*
         * allocate space for presenceOfLight data
         */
        (* presenceOfLight_val_ptr_ptr ) = malloc(rowreq_ctx->data.presenceOfLight_len* sizeof(rowreq_ctx->data.presenceOfLight[0]));
        if(NULL == (* presenceOfLight_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.presenceOfLight)\n");
            return MFD_ERROR;
        }
    }
    (* presenceOfLight_val_ptr_len_ptr ) = rowreq_ctx->data.presenceOfLight_len* sizeof(rowreq_ctx->data.presenceOfLight[0]);
    memcpy( (* presenceOfLight_val_ptr_ptr ), rowreq_ctx->data.presenceOfLight, rowreq_ctx->data.presenceOfLight_len* sizeof(rowreq_ctx->data.presenceOfLight[0]) );

    return MFD_SUCCESS;
} /* presenceOfLight_get */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpDSPStatusEntry.localOscillatorRunning
 * localOscillatorRunning is subid 10 of txpDSPStatusEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.43484.2.9.3.1.1.10
 * Description:
txp40G DSP Local oscillator running.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the localOscillatorRunning data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param localOscillatorRunning_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param localOscillatorRunning_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by localOscillatorRunning.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*localOscillatorRunning_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update localOscillatorRunning_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
localOscillatorRunning_get( txpDSPStatusTable_rowreq_ctx *rowreq_ctx, char **localOscillatorRunning_val_ptr_ptr, size_t *localOscillatorRunning_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != localOscillatorRunning_val_ptr_ptr) && (NULL != *localOscillatorRunning_val_ptr_ptr));
   netsnmp_assert( NULL != localOscillatorRunning_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:txpDSPStatusTable:localOscillatorRunning_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the localOscillatorRunning data.
 * copy (* localOscillatorRunning_val_ptr_ptr ) data and (* localOscillatorRunning_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for localOscillatorRunning data
     */
    if ((NULL == (* localOscillatorRunning_val_ptr_ptr )) ||
        ((* localOscillatorRunning_val_ptr_len_ptr ) <
         (rowreq_ctx->data.localOscillatorRunning_len* sizeof(rowreq_ctx->data.localOscillatorRunning[0])))) {
        /*
         * allocate space for localOscillatorRunning data
         */
        (* localOscillatorRunning_val_ptr_ptr ) = malloc(rowreq_ctx->data.localOscillatorRunning_len* sizeof(rowreq_ctx->data.localOscillatorRunning[0]));
        if(NULL == (* localOscillatorRunning_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.localOscillatorRunning)\n");
            return MFD_ERROR;
        }
    }
    (* localOscillatorRunning_val_ptr_len_ptr ) = rowreq_ctx->data.localOscillatorRunning_len* sizeof(rowreq_ctx->data.localOscillatorRunning[0]);
    memcpy( (* localOscillatorRunning_val_ptr_ptr ), rowreq_ctx->data.localOscillatorRunning, rowreq_ctx->data.localOscillatorRunning_len* sizeof(rowreq_ctx->data.localOscillatorRunning[0]) );

    return MFD_SUCCESS;
} /* localOscillatorRunning_get */

/*---------------------------------------------------------------------
 * FTNC-MIB::txpDSPStatusEntry.transmitLaserRunning
 * transmitLaserRunning is subid 11 of txpDSPStatusEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.43484.2.9.3.1.1.11
 * Description:
txp40G DSP Transmit laser running.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the transmitLaserRunning data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param transmitLaserRunning_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param transmitLaserRunning_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by transmitLaserRunning.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*transmitLaserRunning_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update transmitLaserRunning_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
transmitLaserRunning_get( txpDSPStatusTable_rowreq_ctx *rowreq_ctx, char **transmitLaserRunning_val_ptr_ptr, size_t *transmitLaserRunning_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != transmitLaserRunning_val_ptr_ptr) && (NULL != *transmitLaserRunning_val_ptr_ptr));
   netsnmp_assert( NULL != transmitLaserRunning_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:txpDSPStatusTable:transmitLaserRunning_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the transmitLaserRunning data.
 * copy (* transmitLaserRunning_val_ptr_ptr ) data and (* transmitLaserRunning_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for transmitLaserRunning data
     */
    if ((NULL == (* transmitLaserRunning_val_ptr_ptr )) ||
        ((* transmitLaserRunning_val_ptr_len_ptr ) <
         (rowreq_ctx->data.transmitLaserRunning_len* sizeof(rowreq_ctx->data.transmitLaserRunning[0])))) {
        /*
         * allocate space for transmitLaserRunning data
         */
        (* transmitLaserRunning_val_ptr_ptr ) = malloc(rowreq_ctx->data.transmitLaserRunning_len* sizeof(rowreq_ctx->data.transmitLaserRunning[0]));
        if(NULL == (* transmitLaserRunning_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.transmitLaserRunning)\n");
            return MFD_ERROR;
        }
    }
    (* transmitLaserRunning_val_ptr_len_ptr ) = rowreq_ctx->data.transmitLaserRunning_len* sizeof(rowreq_ctx->data.transmitLaserRunning[0]);
    memcpy( (* transmitLaserRunning_val_ptr_ptr ), rowreq_ctx->data.transmitLaserRunning, rowreq_ctx->data.transmitLaserRunning_len* sizeof(rowreq_ctx->data.transmitLaserRunning[0]) );

    return MFD_SUCCESS;
} /* transmitLaserRunning_get */



/** @} */
